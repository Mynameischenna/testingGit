package com.hrlc.compliance.controller;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.hrlc.compliance.service.xmlService;

@RestController
@RequestMapping("/file-processor")
public class Fileprocess {

    private static final String SOURCE_FOLDER = "C:\\file processor\\new files";
    private static final String DESTINATION_FOLDER = "C:\\file processor\\done";

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    @Autowired
    private xmlService yourService; // Replace YourService with your actual service class

    @PostMapping("/start")
    public ResponseEntity<String> startFileProcessing() {
        // Schedule a task to process files every minute
        scheduler.scheduleAtFixedRate(this::processFiles, 0, 20, TimeUnit.SECONDS);
        return ResponseEntity.ok("File processing started.");
    }

    private void processFiles() {
        try {
            Path sourceFolder = Paths.get(SOURCE_FOLDER);
            Path destinationFolder = Paths.get(DESTINATION_FOLDER);

            Files.walkFileTree(sourceFolder, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    // Process each file
                    System.out.println("Processing file: " + file.getFileName());

                    // Read file content as a string
                    String fileContent = new String(Files.readAllBytes(file));

                    // Call the method with file content as string parameter
                    yourService.processXmlData(fileContent);

                    // Move the file to the destination folder
                    Path destinationFile = destinationFolder.resolve(file.getFileName());
                    Files.move(file, destinationFile, StandardCopyOption.REPLACE_EXISTING);
                    System.out.println("File processed and moved: " + file.getFileName());

                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



package com.hrlc.compliance.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class UserInfo {
	@Id
	private String logonId;
    private String lastName;
    private String phoneNbr;
    private String jobTitle;
    private String middleName;
    private String areaCode;
    private String firstName;
    private String emailAddress;
	
	public String getLogonId() {
		return logonId;
	}
	public void setLogonId(String logonId) {
		this.logonId = logonId;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	public String getPhoneNbr() {
		return phoneNbr;
	}
	public void setPhoneNbr(String string) {
		this.phoneNbr = string;
	}
	public String getJobTitle() {
		return jobTitle;
	}
	public void setJobTitle(String jobTitle) {
		this.jobTitle = jobTitle;
	}
	public String getMiddleName() {
		return middleName;
	}
	public void setMiddleName(String middleName) {
		this.middleName = middleName;
	}
	public String getAreaCode() {
		return areaCode;
	}
	public void setAreaCode(String string) {
		this.areaCode = string;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getEmailAddress() {
		return emailAddress;
	}
	public void setEmailAddress(String emailAddress) {
		this.emailAddress = emailAddress;
	}
	@Override
	public String toString() {
		return "UserInfoEntity [logonId=" + logonId + ", lastName=" + lastName + ", phoneNbr=" + phoneNbr
				+ ", jobTitle=" + jobTitle + ", middleName=" + middleName + ", areaCode=" + areaCode + ", firstName="
				+ firstName + ", emailAddress=" + emailAddress + "]";
	}
    
    

}






package com.hrlc.compliance.entity;



import java.time.LocalDate;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class PlanInfo {
	 	@Id
	    private String evId;
	    private String planName;
	    private String irsrlCode;
	    private String provCompany;
	    private String prodId;
	    private String statusCode;
	    private String dpDateTime;
	    private String rolloverInd;
	    private String gaId;
	    private String clientName;
	    private String firstLineMailing;
	    private String scndLineMailing;
	    private String city;
	    private String stateCode;
	    private String zipCode;
	    private String country;
	    private String internalComplianceInd;
	    private String planAnnivDate;
	    private String estNumberOfParticipants;
	    private String estPlanAssets;
	    private LocalDate estImplementationDate;
	    private String subsetCashCode;
	    private String clientEntityType;
	    private String tpaFirmId;
		
	    
	    
	    public String getEvId() {
	        return evId;
	    }

	    public void setEvId(String evId) {
	        this.evId = evId;
	    }
		public String getPlanName() {
			return planName;
		}
		public void setPlanName(String planName) {
			this.planName = planName;
		}
		public String getIrsrlCode() {
			return irsrlCode;
		}
		public void setIrsrlCode(String irsrlCode) {
			this.irsrlCode = irsrlCode;
		}
		public String getProvCompany() {
			return provCompany;
		}
		public void setProvCompany(String provCompany) {
			this.provCompany = provCompany;
		}
		public String getProdId() {
			return prodId;
		}
		public void setProdId(String prodId) {
			this.prodId = prodId;
		}
		public String getStatusCode() {
			return statusCode;
		}
		public void setStatusCode(String statusCode) {
			this.statusCode = statusCode;
		}
		public String getDpDateTime() {
			return dpDateTime;
		}
		public void setDpDateTime(String dpDateTime) {
			this.dpDateTime = dpDateTime;
		}
		public String getRolloverInd() {
			return rolloverInd;
		}
		public void setRolloverInd(String rolloverInd) {
			this.rolloverInd = rolloverInd;
		}
		public String getGaId() {
			return gaId;
		}
		public void setGaId(String gaId) {
			this.gaId = gaId;
		}
		public String getClientName() {
			return clientName;
		}
		public void setClientName(String clientName) {
			this.clientName = clientName;
		}
		public String getFirstLineMailing() {
			return firstLineMailing;
		}
		public void setFirstLineMailing(String firstLineMailing) {
			this.firstLineMailing = firstLineMailing;
		}
		public String getScndLineMailing() {
			return scndLineMailing;
		}
		public void setScndLineMailing(String scndLineMailing) {
			this.scndLineMailing = scndLineMailing;
		}
		public String getCity() {
			return city;
		}
		public void setCity(String city) {
			this.city = city;
		}
		public String getStateCode() {
			return stateCode;
		}
		public void setStateCode(String stateCode) {
			this.stateCode = stateCode;
		}
		public String getZipCode() {
			return zipCode;
		}
		public void setZipCode(String zipCode) {
			this.zipCode = zipCode;
		}
		public String getCountry() {
			return country;
		}
		public void setCountry(String country) {
			this.country = country;
		}
		public String getInternalComplianceInd() {
			return internalComplianceInd;
		}
		public void setInternalComplianceInd(String internalComplianceInd) {
			this.internalComplianceInd = internalComplianceInd;
		}
		public String getPlanAnnivDate() {
			return planAnnivDate;
		}
		public void setPlanAnnivDate(String planAnnivDate) {
			this.planAnnivDate = planAnnivDate;
		}
		public String getEstNumberOfParticipants() {
			return estNumberOfParticipants;
		}
		public void setEstNumberOfParticipants(String estNumberOfParticipants) {
			this.estNumberOfParticipants = estNumberOfParticipants;
		}
		public String getEstPlanAssets() {
			return estPlanAssets;
		}
		public void setEstPlanAssets(String estPlanAssets) {
			this.estPlanAssets = estPlanAssets;
		}
		public LocalDate getEstImplementationDate() {
			return estImplementationDate;
		}
		public void setEstImplementationDate(LocalDate estImplementationDate) {
			this.estImplementationDate = estImplementationDate;
		}
		public String getSubsetCashCode() {
			return subsetCashCode;
		}
		public void setSubsetCashCode(String subsetCashCode) {
			this.subsetCashCode = subsetCashCode;
		}
		public String getClientEntityType() {
			return clientEntityType;
		}
		public void setClientEntityType(String clientEntityType) {
			this.clientEntityType = clientEntityType;
		}
		public String getTpaFirmId() {
			return tpaFirmId;
		}
		public void setTpaFirmId(String tpaFirmId) {
			this.tpaFirmId = tpaFirmId;
		}
		@Override
		public String toString() {
			return "PlanInfo [ evId=" + evId + ", planName=" + planName + ", irsrlCode=" + irsrlCode
					+ ", provCompany=" + provCompany + ", prodId=" + prodId + ", statusCode=" + statusCode + ", dpDateTime="
					+ dpDateTime + ", rolloverInd=" + rolloverInd + ", gaId=" + gaId + ", clientName=" + clientName
					+ ", firstLineMailing=" + firstLineMailing + ", scndLineMailing=" + scndLineMailing + ", city=" + city
					+ ", stateCode=" + stateCode + ", zipCode=" + zipCode + ", country=" + country
					+ ", internalComplianceInd=" + internalComplianceInd + ", planAnnivDate=" + planAnnivDate
					+ ", estNumberOfParticipants=" + estNumberOfParticipants + ", estPlanAssets=" + estPlanAssets
					+ ", estImplementationDate=" + estImplementationDate + ", subsetCashCode=" + subsetCashCode
					+ ", clientEntityType=" + clientEntityType + ", tpaFirmId=" + tpaFirmId + "]";
		}
	
}



package com.hrlc.compliance.service;
import java.io.StringReader;
import java.time.LocalDate;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import com.hrlc.compliance.entity.ContactInfo;
import com.hrlc.compliance.entity.PlanInfo;
import com.hrlc.compliance.entity.UserInfo;

import com.hrlc.compliance.repository.ContactInfoRepository;
import com.hrlc.compliance.repository.PlanInfoRepository;
import com.hrlc.compliance.repository.UserInfoRepository;





@Service
public class xmlService {
	@Autowired
	private UserInfoRepository userInfoRepo;
	
	@Autowired
	private	PlanInfoRepository planInfoRepo;
	
	@Autowired
	private ContactInfoRepository contactInfoRepo;
	
	public List<PlanInfo> getPlanInfo()
	{
		return planInfoRepo.findAll();
	}
	
	public List<ContactInfo> getContactInfo()
	{
		return contactInfoRepo.findAll();
	}
	public List<UserInfo> getUserInfo()
	{
		return userInfoRepo.findAll();
	}
	public ResponseEntity<String> processXmlData(String xmlData) {
		try {
	        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
	        DocumentBuilder dbuilder = dbfactory.newDocumentBuilder();
	        Document document = dbuilder.parse(new InputSource(new StringReader(xmlData)));

	        NodeList parentNodes = document.getElementsByTagName("*"); // Get all parent nodes

	        for (int i = 0; i < parentNodes.getLength(); i++) {
	            Element parent = (Element) parentNodes.item(i);

	            switch (parent.getTagName()) {
	                case "user_info":
	                    saveUserInfo(parent);
	                    break;
	                case "plan_info":
	                    savePlanInfo(parent);
	                    break;
	                case "contact_info":
	                    saveContactInfo(parent);
	                    break;
	                
	            }
	        }

	        return new ResponseEntity<>("Data saved successfully ", HttpStatus.OK);
	    } catch (Exception e) {
	        e.printStackTrace();
	        return new ResponseEntity<>("Failed to process XML data", HttpStatus.INTERNAL_SERVER_ERROR);
	    }
	}

	private void saveUserInfo(Element parent) {
	    UserInfo userInfo = new UserInfo();

	    userInfo.setLogonId(getElementValue(parent, "logon_id"));
	    userInfo.setLastName(getElementValue(parent, "last_name"));
	    userInfo.setPhoneNbr(getElementValue(parent, "phone_nbr"));
	    userInfo.setJobTitle(getElementValue(parent, "job_title"));
	    userInfo.setMiddleName(getElementValue(parent, "middle_name"));
	    userInfo.setAreaCode(getElementValue(parent, "area_code"));
	    userInfo.setFirstName(getElementValue(parent, "first_name"));
	    userInfo.setEmailAddress(getElementValue(parent, "email_address"));
	    userInfoRepo.save(userInfo);
	    
	}
	
	private void savePlanInfo(Element parent) {
		PlanInfo planInfo = new PlanInfo();
		
		planInfo.setEvId(getElementValue(parent,"ev_id"));
	 	planInfo.setPlanName(getElementValue(parent, "plan_name"));
        planInfo.setIrsrlCode(getElementValue(parent, "irsrl_code"));
        planInfo.setProvCompany(getElementValue(parent, "prov_company"));
        planInfo.setProdId(getElementValue(parent, "prod_id"));
        planInfo.setStatusCode(getElementValue(parent, "status_code"));
        planInfo.setDpDateTime(getElementValue(parent, "dpdate_time"));
        planInfo.setRolloverInd(getElementValue(parent, "rollover_ind"));
        planInfo.setGaId(getElementValue(parent, "ga_id"));
        planInfo.setClientName(getElementValue(parent, "client_name"));
        planInfo.setFirstLineMailing(getElementValue(parent, "first_line_mailing"));
        planInfo.setScndLineMailing(getElementValue(parent, "scnd_line_mailing"));
        planInfo.setCity(getElementValue(parent, "city"));
        planInfo.setStateCode(getElementValue(parent, "state_code"));
        planInfo.setZipCode(getElementValue(parent, "zip_code"));
        planInfo.setCountry(getElementValue(parent, "country"));
        planInfo.setInternalComplianceInd(getElementValue(parent, "internal_compliance_ind"));
        planInfo.setPlanAnnivDate(getElementValue(parent, "plan_anniv_date"));
        planInfo.setEstNumberOfParticipants(getElementValue(parent, "est_number_of_participants"));
        planInfo.setEstPlanAssets(getElementValue(parent, "est_plan_assets"));
        planInfo.setEstImplementationDate(LocalDate.parse(getElementValue(parent, "est_implementation_date")));
        planInfo.setSubsetCashCode(getElementValue(parent, "subset_cash_code"));
        planInfo.setClientEntityType(getElementValue(parent, "client_entity_type"));
        planInfo.setTpaFirmId(getElementValue(parent, "tpa_firm_id"));
        planInfoRepo.save(planInfo);
	}

	private void saveContactInfo(Element parent)
	{
		 ContactInfo contactInfo = new ContactInfo();

         contactInfo.setContactId(getElementValue(parent, "contact_id"));
         contactInfo.setFirstName(getElementValue(parent, "first_name"));
         contactInfo.setLastName(getElementValue(parent, "last_name"));
         contactInfo.setJobTitle(getElementValue(parent, "job_title"));
         contactInfo.setCompanyName(getElementValue(parent, "company_name"));
         contactInfo.setFirstLineMailing(getElementValue(parent, "first_line_mailing"));
         contactInfo.setSecondLineMailing(getElementValue(parent, "scnd_line_mailing"));
         contactInfo.setCity(getElementValue(parent, "city"));
         contactInfo.setStateCode(getElementValue(parent, "state_code"));
         contactInfo.setZipCode(getElementValue(parent, "zip_code"));
         contactInfo.setCountry(getElementValue(parent, "country"));
         contactInfo.setPhoneNbr(getElementValue(parent, "phone_nbr"));
         contactInfo.setFaxNbr(getElementValue(parent, "fax_nbr"));
         contactInfo.setEmailAddress(getElementValue(parent, "email_address"));

//          Assuming contact_roles is a list of strings
         NodeList contactRoleNodes = parent.getElementsByTagName("contact_role");
//         for (int i = 0; i < contactRoleNodes.getLength(); i++) {
//             contactInfo.getContactRoles().add(contactRoleNodes.item(i).getTextContent());
//         }

         contactInfoRepo.save(contactInfo);
	}

	private String getElementValue(Element parseElement, String childTagName) {
	    NodeList childNodes = parseElement.getElementsByTagName(childTagName);
	    if (childNodes.getLength() > 0) {
	        return childNodes.item(0).getTextContent();
	    }
	    return null;
	}
	
	
}
	







import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import com.hrlc.compliance.entity.PlanInfo;
import com.hrlc.compliance.entity.UserInfo;
import com.hrlc.compliance.entity.ContactInfo;
import com.hrlc.compliance.repository.PlanInfoRepository;
import com.hrlc.compliance.repository.UserInfoRepository;
import com.hrlc.compliance.repository.ContactInfoRepository;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RestController
public class ReplaceDotTags {

    private final PlanInfoRepository planInfoRepository;
    private final UserInfoRepository userInfoRepository;
    private final ContactInfoRepository contactInfoRepository;

    public ReplaceDotTags(PlanInfoRepository planInfoRepository, UserInfoRepository userInfoRepository, ContactInfoRepository contactInfoRepository) {
        this.planInfoRepository = planInfoRepository;
        this.userInfoRepository = userInfoRepository;
        this.contactInfoRepository = contactInfoRepository;
    }

    @PostMapping("/generate-dot-files")
    public ResponseEntity<List<String>> generateDotFiles() {
        try {
            List<PlanInfo> allPlanInfos = planInfoRepository.findAll();
            List<UserInfo> allUserInfos = userInfoRepository.findAll();
            List<ContactInfo> allContactInfos = contactInfoRepository.findAll();
            List<String> filePaths = generateDotFiles(allPlanInfos, allUserInfos, allContactInfos);
            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDotFiles(List<PlanInfo> planInfos, List<UserInfo> userInfos, List<ContactInfo> contactInfos) throws IOException {
        List<String> filePaths = new ArrayList<>();
        for (int i = 0; i < Math.min(planInfos.size(), Math.min(userInfos.size(), contactInfos.size())); i++) {
            PlanInfo planInfo = planInfos.get(i);
            UserInfo userInfo = userInfos.get(i);
            ContactInfo contactInfo = contactInfos.get(i);
            String originalDotFilePath = "C:\\TestXML\\Plan Express Specifications2.dot";
            String copiedDotFilePath = copyDotFile(originalDotFilePath, planInfo.getEvId() + "_" + userInfo.getLogonId() + "_" + contactInfo.getContactId());
            replaceTagsInDot(copiedDotFilePath, planInfo, userInfo, contactInfo);
            filePaths.add(copiedDotFilePath);
        }
        return filePaths;
    }

    private String copyDotFile(String originalDotFilePath, String fileName) throws IOException {
        String copiedDotFilePath = "C:\\dummy xml\\" + fileName + "_modified.dot";
        Files.copy(Paths.get(originalDotFilePath), Paths.get(copiedDotFilePath), StandardCopyOption.REPLACE_EXISTING);
        return copiedDotFilePath;
    }

    private void replaceTagsInDot(String dotFilePath, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
        String content = Files.readString(Paths.get(dotFilePath), StandardCharsets.UTF_8);
        content = content.replace("${EV_ID}", planInfo.getEvId())
                         .replace("${PLAN_NAME}", planInfo.getPlanName())
                         .replace("${LOGON_ID}", userInfo.getLogonId())
                         .replace("${CONTACT_ID}", contactInfo.getContactId());

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dotFilePath))) {
            writer.write(content);
        }
    }
}





package com.example.plan.xmlEntityControlller;

import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
public class DocxReplaceController {

    @Autowired
    private xmlRepo xmlEntityRepository; // Replace xmlEntityRepository with your actual repository

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<xmlEntity> allxmlEntity = xmlEntityRepository.findAll();
            System.out.println(allxmlEntity);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allxmlEntity);
            

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<xmlEntity> xmlEntityList) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the data fetched from the database
        for (xmlEntity xmlEntity : xmlEntityList) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\af_plan_provision_summary_document_section_1_09.2020.dot"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, xmlEntity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, xmlEntity.getEvId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current xmlEntity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, xmlEntity xmlEntity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, xmlEntity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, xmlEntity planInfo) {
        Range range = document.getRange();

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "<ssmPlanNumber>", planInfo.getEvId(),
                "<ssmPlanName>", planInfo.getPlanName()
                // Add more tag replacements as needed
                
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Debugging: Print the tag and replacement value
            System.out.println("Replacing tag: " + tag);
            System.out.println("With value: " + replacement);

            // Replace the tag in the document
            range.replaceText(tag, replacement);
        }
    }
 
//        document.getParagraphs().forEach(paragraph -> {
//            // Iterate through all runs in the paragraph
//            for (XWPFRun run : paragraph.getRuns()) {
//                // Get the text content of the run
//                String text = run.getText(0);
//
//                // Debugging: Print the text and replacement value
//                System.out.println("Original Text: " + text);
//                System.out.println("Replacement Value: " + xmlEntity.getEvId());
//
//                // Replace the <ev_id></ev_id> tag with the actual evId from xmlEntity
//                if (text != null && text.contains("<plan_name></plan_name>")) {
//                    run.setText(text.replace("<plan_name></plan_name>", xmlEntity.getPlanName()), 0);
//                }
//                else if (text.contains("<ev_id></ev_id>")) {
//                    // Replace {planName} with the actual planName from xmlEntity
//                    run.setText(text.replace("<ev_id></ev_id>", xmlEntity.getEvId()), 0);
//                }
//
//                // Debugging: Print the modified text after replacement
//                System.out.println("Modified Text: " + run.getText(0));
//            }
//        });
//    }
    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
    }


private void replaceTagsInDot(String dotFilePath, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
    try {
        // Read the .dot file content using ISO-8859-1 encoding
        List<String> lines = Files.readAllLines(Paths.get(dotFilePath), StandardCharsets.ISO_8859_1);

        // Replace placeholders in each line
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            line = line.replace("${EV_ID}", planInfo.getEvId())
                       .replace("${PLAN_NAME}", planInfo.getPlanName())
                       .replace("${LOGON_ID}", userInfo.getLogonId())
                       .replace("${CONTACT_ID}", contactInfo.getContactId());
            lines.set(i, line);
        }

        // Write the modified content back to the .dot file
        Files.write(Paths.get(dotFilePath), lines, StandardCharsets.ISO_8859_1);
    } catch (MalformedInputException e) {
        // Handle encoding errors gracefully (e.g., skip problematic characters)
        System.err.println("Encoding error occurred: " + e.getMessage());
    } catch (IOException e) {
        // Handle other I/O errors
        e.printStackTrace();
    }
}




import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import com.hrlc.compliance.entity.PlanInfo;
import com.hrlc.compliance.entity.UserInfo;
import com.hrlc.compliance.entity.ContactInfo;
import com.hrlc.compliance.repository.PlanInfoRepository;
import com.hrlc.compliance.repository.UserInfoRepository;
import com.hrlc.compliance.repository.ContactInfoRepository;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
public class ReplaceDotTags {

    private final PlanInfoRepository planInfoRepository;
    private final UserInfoRepository userInfoRepository;
    private final ContactInfoRepository contactInfoRepository;

    public ReplaceDotTags(PlanInfoRepository planInfoRepository, UserInfoRepository userInfoRepository, ContactInfoRepository contactInfoRepository) {
        this.planInfoRepository = planInfoRepository;
        this.userInfoRepository = userInfoRepository;
        this.contactInfoRepository = contactInfoRepository;
    }

    @PostMapping("/generate-dot-files")
    public ResponseEntity<List<String>> generateDotFiles() {
        try {
            List<PlanInfo> allPlanInfos = planInfoRepository.findAll();
            List<UserInfo> allUserInfos = userInfoRepository.findAll();
            List<ContactInfo> allContactInfos = contactInfoRepository.findAll();
            List<String> filePaths = generateDotFiles(allPlanInfos, allUserInfos, allContactInfos);
            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDotFiles(List<PlanInfo> planInfos, List<UserInfo> userInfos, List<ContactInfo> contactInfos) throws IOException {
        List<String> filePaths = new ArrayList<>();
        for (int i = 0; i < Math.min(planInfos.size(), Math.min(userInfos.size(), contactInfos.size())); i++) {
            PlanInfo planInfo = planInfos.get(i);
            UserInfo userInfo = userInfos.get(i);
            ContactInfo contactInfo = contactInfos.get(i);
            String originalDotFilePath = "C:\\TestXML\\Plan Express Specifications2.dot";
            String copiedDotFilePath = copyDotFile(originalDotFilePath, planInfo.getEvId() + "_" + userInfo.getLogonId() + "_" + contactInfo.getContactId());
            replaceTagsInDot(copiedDotFilePath, planInfo, userInfo, contactInfo);
            filePaths.add(copiedDotFilePath);
        }
        return filePaths;
    }

    private String copyDotFile(String originalDotFilePath, String fileName) throws IOException {
        String copiedDotFilePath = "C:\\dummy xml\\" + fileName + "_modified.dot";
        Files.copy(Paths.get(originalDotFilePath), Paths.get(copiedDotFilePath), StandardCopyOption.REPLACE_EXISTING);
        return copiedDotFilePath;
    }

    private void replaceTagsInDot(String dotFilePath, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(dotFilePath), StandardCharsets.UTF_8);
        List<String> modifiedLines = lines.stream()
                .map(line -> line.replace("${EV_ID}", planInfo.getEvId())
                                 .replace("${PLAN_NAME}", planInfo.getPlanName())
                                 .replace("${LOGON_ID}", userInfo.getLogonId())
                                 .replace("${CONTACT_ID}", contactInfo.getContactId()))
                .collect(Collectors.toList());
        Files.write(Paths.get(dotFilePath), modifiedLines, StandardCharsets.UTF_8);
    }
}



// Import statements and annotations

@RestController
public class ReplaceDotTags {

    @Autowired
    private PlanInfoRepository planInfoRepository;

    @Autowired
    private UserInfoRepository userInfoRepository;

    @Autowired
    private ContactInfoRepository contactInfoRepository;

    @PostMapping("/generate-dot-files")
    public ResponseEntity<List<String>> generateDotFiles() {
        try {
            // Fetch all data from the database
            List<PlanInfo> allPlanInfos = planInfoRepository.findAll();
            List<UserInfo> allUserInfos = userInfoRepository.findAll();
            List<ContactInfo> allContactInfos = contactInfoRepository.findAll();

            // Create a list to store the file paths of the generated DOT files
            List<String> filePaths = generateDotFiles(allPlanInfos, allUserInfos, allContactInfos);

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDotFiles(List<PlanInfo> planInfos, List<UserInfo> userInfos, List<ContactInfo> contactInfos) throws IOException {
        // Create a list to store the file paths of the generated DOT files
        List<String> filePaths = new ArrayList<>();

        // Iterate over each row of data from the tables simultaneously
        for (int i = 0; i < Math.min(planInfos.size(), Math.min(userInfos.size(), contactInfos.size())); i++) {
            PlanInfo planInfo = planInfos.get(i);
            UserInfo userInfo = userInfos.get(i);
            ContactInfo contactInfo = contactInfos.get(i);

            try {
                // Copy the original .dot template file
                String originalDotFilePath = "C:\\TestXML\\Plan Express Specifications2.dot";
                String copiedDotFilePath = copyDotFile(originalDotFilePath, planInfo.getEvId() + "_" + userInfo.getLogonId() + "_" + contactInfo.getContactId());

                // Replace placeholders in the copied .dot file
                replaceTagsInDot(copiedDotFilePath, planInfo, userInfo, contactInfo);

                // Add the file path to the list
                filePaths.add(copiedDotFilePath);
            } catch (IOException e) {
                // Handle exceptions for the current entities if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private void replaceTagsInDot(String dotFilePath, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
        // Replace placeholders in the .dot file with data from PlanInfo, UserInfo, and ContactInfo entities
        String templateText = Files.readString(Paths.get(dotFilePath), StandardCharsets.UTF_8);
        templateText = templateText.replace("${EV_ID}", planInfo.getEvId())
                                   .replace("${PLAN_NAME}", planInfo.getPlanName())
                                   .replace("${LOGON_ID}", userInfo.getLogonId())
                                   .replace("${CONTACT_ID}", contactInfo.getContactId());

        // Write the modified text back to the .dot file
        Files.write(Paths.get(dotFilePath), templateText.getBytes(StandardCharsets.UTF_8));
    }

    private String copyDotFile(String originalDotFilePath, String fileName) throws IOException {
        String copiedDotFilePath = "C:\\dummy xml\\" + fileName + "_modified.dot";
        Files.copy(Paths.get(originalDotFilePath), Paths.get(copiedDotFilePath), StandardCopyOption.REPLACE_EXISTING);
        return copiedDotFilePath;
    }
}




// Import statements and annotations

@RestController
public class ReplaceDotTags {

    @Autowired
    private PlanInfoRepository planInfoRepository;

    @Autowired
    private UserInfoRepository userInfoRepository;

    @Autowired
    private ContactInfoRepository contactInfoRepository;

    @PostMapping("/generate-doc-files")
    public ResponseEntity<List<String>> generateDocFiles() {
        try {
            // Fetch all data from the database
            List<PlanInfo> allPlanInfos = planInfoRepository.findAll();
            List<UserInfo> allUserInfos = userInfoRepository.findAll();
            List<ContactInfo> allContactInfos = contactInfoRepository.findAll();

            // Create a list to store the file paths of the generated DOC files
            List<String> filePaths = generateDocFiles(allPlanInfos, allUserInfos, allContactInfos);

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocFiles(List<PlanInfo> planInfos, List<UserInfo> userInfos, List<ContactInfo> contactInfos) throws IOException {
        // Create a list to store the file paths of the generated DOC files
        List<String> filePaths = new ArrayList<>();

        // Read the .dot template file content
        byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.dot"));

        // Iterate over each row of data from the tables simultaneously
        for (int i = 0; i < Math.min(planInfos.size(), Math.min(userInfos.size(), contactInfos.size())); i++) {
            PlanInfo planInfo = planInfos.get(i);
            UserInfo userInfo = userInfos.get(i);
            ContactInfo contactInfo = contactInfos.get(i);

            try {
                // Replace placeholders in the .dot template and create a new .docx file
                byte[] modifiedDocument = replaceTagsInDot(dotTemplateContent, planInfo, userInfo, contactInfo);

                // Save the modified DOCX file
                String filePath = saveModifiedDocFile(modifiedDocument, planInfo.getEvId() + "_" + userInfo.getLogonId() + "_" + contactInfo.getContactId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current entities if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceTagsInDot(byte[] dotTemplateContent, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
        // Replace placeholders in the .dot template with data from PlanInfo, UserInfo, and ContactInfo entities
        String templateText = new String(dotTemplateContent, StandardCharsets.UTF_8);
        templateText = templateText.replace("${EV_ID}", planInfo.getEvId())
                                   .replace("${PLAN_NAME}", planInfo.getPlanName())
                                   .replace("${LOGON_ID}", userInfo.getLogonId())
                                   .replace("${CONTACT_ID}", contactInfo.getContactId());

        // Convert the modified text back to byte array
        return templateText.getBytes(StandardCharsets.UTF_8);
    }

    private String saveModifiedDocFile(byte[] modifiedDocContent, String fileName) throws IOException {
        String filePath = "C:\\dummy xml\\" + fileName + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocContent);
        }
        return filePath;
    }
}





// Import statements and annotations

@RestController
public class ReplaceDocxTags {

    @Autowired
    private PlanInfoRepository planInfoRepository;

    @Autowired
    private UserInfoRepository userInfoRepository;

    @Autowired
    private ContactInfoRepository contactInfoRepository;

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<PlanInfo> allPlanInfos = planInfoRepository.findAll();
            List<UserInfo> allUserInfos = userInfoRepository.findAll();
            List<ContactInfo> allContactInfos = contactInfoRepository.findAll();

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allPlanInfos, allUserInfos, allContactInfos);

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<PlanInfo> planInfos, List<UserInfo> userInfos, List<ContactInfo> contactInfos) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over each row of data from the tables simultaneously
        for (int i = 0; i < Math.min(planInfos.size(), Math.min(userInfos.size(), contactInfos.size())); i++) {
            PlanInfo planInfo = planInfos.get(i);
            UserInfo userInfo = userInfos.get(i);
            ContactInfo contactInfo = contactInfos.get(i);

            try {
                // Read the DOCX template file content
                byte[] templateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.docx"));

                // Replace placeholders in the DOCX file
                byte[] modifiedDocument = replaceTagsInDocx(templateContent, planInfo, userInfo, contactInfo);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, planInfo.getEvId() + "_" + userInfo.getLogonId() + "_" + contactInfo.getContactId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current entities if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceTagsInDocx(byte[] templateContent, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(templateContent);
             XWPFDocument document = new XWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {

            // Replace placeholders in the document with data from PlanInfo, UserInfo, and ContactInfo entities
            replaceTags(document, planInfo, userInfo, contactInfo);

            // Write the modified content to the output stream
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(XWPFDocument document, PlanInfo planInfo, UserInfo userInfo, ContactInfo contactInfo) {
        // Iterate over paragraphs, runs, tables, etc., and replace placeholders accordingly with data from all entities
        for (XWPFParagraph paragraph : document.getParagraphs()) {
            for (XWPFRun run : paragraph.getRuns()) {
                String text = run.getText(0);
                if (text != null) {
                    text = text.replace("${EV_ID}", planInfo.getEvId())
                               .replace("${PLAN_NAME}", planInfo.getPlanName())
                               .replace("${LOGON_ID}", userInfo.getLogonId())
                               .replace("${CONTACT_ID}", contactInfo.getContactId());
                    run.setText(text, 0);
                }
            }
        }
    }

    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String fileName) throws IOException {
        String filePath = "C:\\dummy xml\\" + fileName + "_modified.docx";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}



package com.hrlc.compliance.controller;

import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import com.hrlc.compliance.entity.PlanInfo;
import com.hrlc.compliance.repository.PlanInfoRepository;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
public class ReplaceDocxTags {

    @Autowired
    private PlanInfoRepository xmlEntityRepository; // Replace xmlEntityRepository with your actual repository

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<PlanInfo> allxmlEntity = xmlEntityRepository.findAll();
            System.out.println(allxmlEntity);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allxmlEntity);
            

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<PlanInfo> xmlEntityList) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the data fetched from the database
        for (PlanInfo xmlEntity : xmlEntityList) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.doc"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, xmlEntity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, xmlEntity.getEvId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current xmlEntity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, PlanInfo xmlEntity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, xmlEntity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, PlanInfo planInfo) {
        Range range = document.getRange();

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "<ssmPlanNumber>", planInfo.getEvId(),
                "<ssmPlanName>", planInfo.getPlanName()
                // Add more tag replacements as needed
                
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Debugging: Print the tag and replacement value
            System.out.println("Replacing tag: " + tag);
            System.out.println("With value: " + replacement);

            // Replace the tag in the document
            range.replaceText(tag, replacement);
        }
    }
 
//        document.getParagraphs().forEach(paragraph -> {
//            // Iterate through all runs in the paragraph
//            for (XWPFRun run : paragraph.getRuns()) {
//                // Get the text content of the run
//                String text = run.getText(0);
//
//                // Debugging: Print the text and replacement value
//                System.out.println("Original Text: " + text);
//                System.out.println("Replacement Value: " + xmlEntity.getEvId());
//
//                // Replace the <ev_id></ev_id> tag with the actual evId from xmlEntity
//                if (text != null && text.contains("<plan_name></plan_name>")) {
//                    run.setText(text.replace("<plan_name></plan_name>", xmlEntity.getPlanName()), 0);
//                }
//                else if (text.contains("<ev_id></ev_id>")) {
//                    // Replace {planName} with the actual planName from xmlEntity
//                    run.setText(text.replace("<ev_id></ev_id>", xmlEntity.getEvId()), 0);
//                }
//
//                // Debugging: Print the modified text after replacement
//                System.out.println("Modified Text: " + run.getText(0));
//            }
//        });
//    }
    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
    }


import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import javax.transaction.Transactional;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;

@Service
@Transactional
public class DocumentProcessorService {

    @Autowired
    private PlanInfoRepository planInfoRepository;

    @Autowired
    private UserInfoRepository userInfoRepository;

    @Autowired
    private ContactInfoRepository contactInfoRepository;

    public void processDocument(String sourceFilePath, String destinationFolder) {
        try (FileInputStream fis = new FileInputStream(sourceFilePath);
             XWPFDocument document = new XWPFDocument(fis)) {

            // Fetch data from PlanInfo table
            List<PlanInfo> planInfos = planInfoRepository.findAll();
            // Iterate over each PlanInfo entity
            for (PlanInfo planInfo : planInfos) {
                // Iterate over paragraphs in the document
                for (XWPFParagraph paragraph : document.getParagraphs()) {
                    // Replace placeholders with data
                    replacePlaceholder(paragraph, "EV_ID", planInfo.getEvId());
                    replacePlaceholder(paragraph, "CITY", planInfo.getCity());
                    replacePlaceholder(paragraph, "CLIENT_ENTITY_TYPE", planInfo.getClientEntityType());
                    // You can add more placeholders and replace them with data from PlanInfo entity
                }
            }

            // Fetch data from UserInfo table
            List<UserInfo> userInfos = userInfoRepository.findAll();
            // Iterate over each UserInfo entity
            for (UserInfo userInfo : userInfos) {
                // Iterate over paragraphs in the document
                for (XWPFParagraph paragraph : document.getParagraphs()) {
                    // Replace placeholders with data
                    replacePlaceholder(paragraph, "LOGON_ID", userInfo.getLogonId());
                    replacePlaceholder(paragraph, "EMAIL_ADDRESS", userInfo.getEmailAddress());
                    // You can add more placeholders and replace them with data from UserInfo entity
                }
            }

            // Fetch data from ContactInfo table
            List<ContactInfo> contactInfos = contactInfoRepository.findAll();
            // Iterate over each ContactInfo entity
            for (ContactInfo contactInfo : contactInfos) {
                // Iterate over paragraphs in the document
                for (XWPFParagraph paragraph : document.getParagraphs()) {
                    // Replace placeholders with data
                    replacePlaceholder(paragraph, "CONTACT_ID", contactInfo.getContactId());
                    replacePlaceholder(paragraph, "COMPANY_NAME", contactInfo.getCompanyName());
                    // You can add more placeholders and replace them with data from ContactInfo entity
                }
            }

            // Write modified content back to a temporary file
            Path tempFilePath = Files.createTempFile("temp", ".docx");
            try (FileOutputStream fos = new FileOutputStream(tempFilePath.toFile())) {
                document.write(fos);
            }

            // Move the temporary file to the destination folder
            Path destinationPath = Paths.get(destinationFolder);
            Files.move(tempFilePath, destinationPath.resolve(tempFilePath.getFileName()), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void replacePlaceholder(XWPFParagraph paragraph, String placeholder, String replacement) {
        String text = paragraph.getText();
        if (text.contains(placeholder)) {
            text = text.replace(placeholder, replacement);
            paragraph.setText(text);
        }
    }
}





CREATE TABLE Plans(
	planID int IDENTITY(1,1) NOT NULL,
	planNumber varchar(50) NOT NULL,
	planName varchar(255) NOT NULL,
    PRIMARY KEY (planID)
);

CREATE TABLE PlanInfo(
	planInfoID int IDENTITY(1,1) NOT NULL,
	planID int NOT NULL,
	ev_id varchar(255) NOT NULL,
	city varchar(255) DEFAULT NULL,
	client_entity_type varchar(255) DEFAULT NULL,
	client_name varchar(255) DEFAULT NULL,
	country varchar(255) DEFAULT NULL,
	dp_date_time varchar(255) DEFAULT NULL,
	est_implementation_date date DEFAULT NULL,
	est_number_of_participants varchar(255) DEFAULT NULL,
	est_plan_assets varchar(255) DEFAULT NULL,
	first_line_mailing varchar(255) DEFAULT NULL,
	ga_id varchar(255) DEFAULT NULL,
	internal_compliance_ind varchar(255) DEFAULT NULL,
	irsrl_code varchar(255) DEFAULT NULL,
	plan_anniv_date varchar(255) DEFAULT NULL,
	plan_name varchar(255) DEFAULT NULL,
	prod_id varchar(255) DEFAULT NULL,
	prov_company varchar(255) DEFAULT NULL,
	rollover_ind varchar(255) DEFAULT NULL,
	scnd_line_mailing varchar(255) DEFAULT NULL,
	state_code varchar(255) DEFAULT NULL,
	status_code varchar(255) DEFAULT NULL,
	subset_cash_code varchar(255) DEFAULT NULL,
	tpa_firm_id varchar(255) DEFAULT NULL,
	zip_code varchar(255) DEFAULT NULL,
    PRIMARY KEY (planInfoID),
	FOREIGN KEY (planID) REFERENCES Plans(planID) 
);

CREATE TABLE UserInfo(
	userInfoID int IDENTITY(1,1) NOT NULL,
	planID int NOT NULL,
	logon_id varchar(255) NOT NULL,
	area_code varchar(255) DEFAULT NULL,
	email_address varchar(255) DEFAULT NULL,
	first_name varchar(255) DEFAULT NULL,
	job_title varchar(255) DEFAULT NULL,
	last_name varchar(255) DEFAULT NULL,
	middle_name varchar(255) DEFAULT NULL,
	phone_nbr varchar(255) DEFAULT NULL,
    PRIMARY KEY (userInfoID),
	FOREIGN KEY (planID) REFERENCES Plans(planID) 
);

CREATE TABLE ContactInfo(
	contactInfoID int IDENTITY(1,1) NOT NULL,
	planID int NOT NULL,
	contact_id varchar(255) NOT NULL,
	city varchar(255) DEFAULT NULL,
	company_name varchar(255) DEFAULT NULL,
	country varchar(255) DEFAULT NULL,
	email_address varchar(255) DEFAULT NULL,
	fax_nbr varchar(255) DEFAULT NULL,
	first_line_mailing varchar(255) DEFAULT NULL,
	first_name varchar(255) DEFAULT NULL,
	job_title varchar(255) DEFAULT NULL,
	last_name varchar(255) DEFAULT NULL,
	phone_nbr varchar(255) DEFAULT NULL,
	second_line_mailing varchar(255) DEFAULT NULL,
	state_code varchar(255) DEFAULT NULL,
	zip_code varchar(255) DEFAULT NULL,
    PRIMARY KEY (contactInfoID),
	FOREIGN KEY (planID) REFERENCES Plans(planID) 
);


import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@RestController
@RequestMapping("/file-processor")
public class FileProcessorController {

    private static final String SOURCE_FOLDER = "D:\\Fille Processor\\files";
    private static final String DESTINATION_FOLDER = "D:\\Fille Processor\\done";

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    @Autowired
    private YourService yourService; // Replace YourService with your actual service class

    @PostMapping("/start")
    public ResponseEntity<String> startFileProcessing() {
        // Schedule a task to process files every minute
        scheduler.scheduleAtFixedRate(this::processFiles, 0, 1, TimeUnit.MINUTES);
        return ResponseEntity.ok("File processing started.");
    }

    private void processFiles() {
        try {
            Path sourceFolder = Paths.get(SOURCE_FOLDER);
            Path destinationFolder = Paths.get(DESTINATION_FOLDER);

            Files.walkFileTree(sourceFolder, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    // Process each file
                    System.out.println("Processing file: " + file.getFileName());

                    // Read file content as a string
                    String fileContent = new String(Files.readAllBytes(file));

                    // Call the method with file content as string parameter
                    yourService.processFile(fileContent);

                    // Move the file to the destination folder
                    Path destinationFile = destinationFolder.resolve(file.getFileName());
                    Files.move(file, destinationFile, StandardCopyOption.REPLACE_EXISTING);
                    System.out.println("File processed and moved: " + file.getFileName());

                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.poi.xwml.usermodel.*;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class DotFileProcessor {

    public static void main(String[] args) {
        // Replace these with your actual file paths
        String folderPath = "/path/to/xml/folder";
        String docFilePath = "/path/to/your/doc/file.doc";
        String outputFolder = "/path/to/output/folder";

        // Process each XML file in the folder
        File folder = new File(folderPath);
        for (File xmlFile : folder.listFiles()) {
            if (xmlFile.getName().endsWith(".xml")) {
                processFile(xmlFile, docFilePath, outputFolder);
            }
        }
    }

    private static void processFile(File xmlFile, String docFilePath, String outputFolder) {
        List<Map<String, String>> dataList = parseXml(xmlFile);

        for (int i = 0; i < dataList.size(); i++) {
            Map<String, String> dataMap = dataList.get(i);
            String outputFileName = xmlFile.getName() + "_row_" + (i + 1) + ".doc";
            String outputFilePath = new File(outputFolder, outputFileName).getPath();
            replaceTagsInDocFile(docFilePath, dataMap, outputFilePath);
        }
    }

    private static List<Map<String, String>> parseXml(File xmlFile) {
        List<Map<String, String>> dataList = new ArrayList<>();

        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(xmlFile);

            doc.getDocumentElement().normalize();

            // Extract data from relevant tags in each entity
            for (String entityType : new String[]{"plan_info", "user_info", "contact_info"}) {
                NodeList nodes = doc.getElementsByTagName(entityType);
                for (int i = 0; i < nodes.getLength(); i++) {
                    Node node = nodes.item(i);
                    if (node.getNodeType() == Node.ELEMENT_NODE) {
                        Element element = (Element) node;
                        Map<String, String> dataMap = new HashMap<>();
                        for (Element childElement : getChildren(element)) {
                            dataMap.put(entityType + "_" + childElement.getNodeName(), childElement.getTextContent());
                        }
                        dataList.add(dataMap);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return dataList;
    }

    private static List<Element> getChildren(Element element) {
        List<Element> children = new ArrayList<>();
        NodeList childNodes = element.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node childNode = childNodes.item(i);
            if (childNode.getNodeType() == Node.ELEMENT_NODE) {
                children.add((Element) childNode);
            }
        }
        return children;
    }

    private static void replaceTagsInDocFile(String docFilePath, Map<String, String> dataMap, String outputFilePath) {
        try {
            XWPFDocument doc = new XWPFDocument(new FileInputStream(docFilePath));
            for (XWPFParagraph paragraph : doc.



// Import statements...

@RestController
public class ReplaceDocxTags {

    @Autowired
    private PlanInfoRepository planInfoRepository; // Inject PlanInfo repository
    @Autowired
    private ContactInfoRepository contactInfoRepository; // Inject ContactInfo repository
    @Autowired
    private UserInfoRepository userInfoRepository; // Inject UserInfo repository

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Create a list of entity repositories you want to process
            List<JpaRepository<?, ?>> entityRepositories = Arrays.asList(planInfoRepository, contactInfoRepository, userInfoRepository);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(entityRepositories);

            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<JpaRepository<?, ?>> entityRepositories) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the specified entity repositories
        for (JpaRepository<?, ?> entityRepository : entityRepositories) {
            // Fetch all data from the database for the current entity repository
            List<?> allEntities = entityRepository.findAll();

            // Create a list to store the file paths for the current entity repository
            List<String> entityFilePaths = generateDocxFiles(allEntities);

            // Add the file paths to the main list
            filePaths.addAll(entityFilePaths);
        }

        return filePaths;
    }

    private List<String> generateDocxFiles(List<?> entities) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the entities
        for (Object entity : entities) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.doc"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, entity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, entity.getClass().getSimpleName());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current entity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, Object entity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, entity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, Object entity) {
        Range range = document.getRange();

        // Define your tag replacements based on the entity class
        if (entity instanceof PlanInfo) {
            PlanInfo planInfo = (PlanInfo) entity;
            Map<String, String> tagReplacements = Map.of(
                    "<planInfoTag>", planInfo.getPlanInfoValue(),
                    // Add more tag replacements as needed
            );

            // Iterate through the tag replacements
            for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
                String tag = entry.getKey();
                String replacement = entry.getValue();

                // Debugging: Print the tag and replacement value
                System.out.println("Replacing tag: " + tag);
                System.out.println("With value: " + replacement);

                // Replace the tag in the document
                range.replaceText(tag, replacement);
            }
        } else if (entity instanceof ContactInfo) {
            ContactInfo contactInfo = (ContactInfo) entity;
            // Define tag replacements for ContactInfo entity
            // ...
        } else if (entity instanceof UserInfo) {
            UserInfo userInfo = (UserInfo) entity;
            // Define tag replacements for UserInfo entity
            // ...
        }

        // Add more conditions for other entity classes as needed
    }

    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String className) throws IOException {
        String filePath = "C:\\dummy xml\\" + className + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}





// Import statements...

@RestController
public class ReplaceDocxTags {

    @Autowired
    private Map<String, JpaRepository<?, String>> entityRepositories; // Autowire repositories for multiple entities

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // List of entity classes you want to process
            List<Class<?>> entityClasses = Arrays.asList(UserInfo.class, ContactInfo.class);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(entityClasses);

            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<Class<?>> entityClasses) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the specified entity classes
        for (Class<?> entityClass : entityClasses) {
            // Fetch all data from the database for the current entity class
            JpaRepository<?, String> entityRepository = entityRepositories.get(entityClass.getSimpleName());
            List<?> allEntities = entityRepository.findAll();

            // Create a list to store the file paths for the current entity class
            List<String> entityFilePaths = generateDocxFiles(allEntities);

            // Add the file paths to the main list
            filePaths.addAll(entityFilePaths);
        }

        return filePaths;
    }

    private List<String> generateDocxFiles(List<?> entities) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the entities
        for (Object entity : entities) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.doc"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, entity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, entity.getClass().getSimpleName());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current entity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, Object entity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, entity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, Object entity) {
        Range range = document.getRange();

        // Define your tag replacements based on the entity class
        if (entity instanceof UserInfo) {
            UserInfo userInfo = (UserInfo) entity;
            Map<String, String> tagReplacements = Map.of(
                    "<userName>", userInfo.getUserName(),
                    "<userEmail>", userInfo.getUserEmail()
                    // Add more tag replacements as needed
            );

            // Iterate through the tag replacements
            for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
                String tag = entry.getKey();
                String replacement = entry.getValue();

                // Debugging: Print the tag and replacement value
                System.out.println("Replacing tag: " + tag);
                System.out.println("With value: " + replacement);

                // Replace the tag in the document
                range.replaceText(tag, replacement);
            }
        } else if (entity instanceof ContactInfo) {
            ContactInfo contactInfo = (ContactInfo) entity;
            // Define tag replacements for ContactInfo entity
            // ...
        }

        // Add more conditions for other entity classes as needed
    }

    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String className) throws IOException {
        String filePath = "C:\\dummy xml\\" + className + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}




package com.hrlc.compliance.controller;

import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import com.hrlc.compliance.entity.PlanInfo;
import com.hrlc.compliance.repository.PlanInfoRepository;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
public class ReplaceDocxTags {

    @Autowired
    private PlanInfoRepository xmlEntityRepository; // Replace xmlEntityRepository with your actual repository

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<PlanInfo> allxmlEntity = xmlEntityRepository.findAll();
            System.out.println(allxmlEntity);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allxmlEntity);
            

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<PlanInfo> xmlEntityList) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the data fetched from the database
        for (PlanInfo xmlEntity : xmlEntityList) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\Plan Express Specifications2.doc"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, xmlEntity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, xmlEntity.getEvId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current xmlEntity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, PlanInfo xmlEntity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, xmlEntity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, PlanInfo planInfo) {
        Range range = document.getRange();

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "<ssmPlanNumber>", planInfo.getEvId(),
                "<ssmPlanName>", planInfo.getPlanName()
                // Add more tag replacements as needed
                
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Debugging: Print the tag and replacement value
            System.out.println("Replacing tag: " + tag);
            System.out.println("With value: " + replacement);

            // Replace the tag in the document
            range.replaceText(tag, replacement);
        }
    }
 
//        document.getParagraphs().forEach(paragraph -> {
//            // Iterate through all runs in the paragraph
//            for (XWPFRun run : paragraph.getRuns()) {
//                // Get the text content of the run
//                String text = run.getText(0);
//
//                // Debugging: Print the text and replacement value
//                System.out.println("Original Text: " + text);
//                System.out.println("Replacement Value: " + xmlEntity.getEvId());
//
//                // Replace the <ev_id></ev_id> tag with the actual evId from xmlEntity
//                if (text != null && text.contains("<plan_name></plan_name>")) {
//                    run.setText(text.replace("<plan_name></plan_name>", xmlEntity.getPlanName()), 0);
//                }
//                else if (text.contains("<ev_id></ev_id>")) {
//                    // Replace {planName} with the actual planName from xmlEntity
//                    run.setText(text.replace("<ev_id></ev_id>", xmlEntity.getEvId()), 0);
//                }
//
//                // Debugging: Print the modified text after replacement
//                System.out.println("Modified Text: " + run.getText(0));
//            }
//        });
//    }
    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
    }




const onClickOkSConfirmModel= async (row:BatchSource)=>{
            setShowBATSConfirmModel(false);
            let response:any=null;
           
                response= removeBatchSource({id: row.id, bkaCode: row.bkaCode, bkaTypeCode: row.bkaTypeCode, db: selectedDb});
           
            if(response?.data===200){
                setShowBATSConfirmModelSuccess(true);
              }else if(response==null||response.error?.data?.error?.message===null){
                setShowBATSConfirmModel(false);
                setAPIErrorMessage("Unknown error occurred");
            }else if(response?.error?.status===500){
                setShowBATSConfirmModel(false);
                setAPIErrorMessage(response.error?.data?.error?.message);
            }
        }
 <InprogressComponent inProgress={isFetchin... by JS, Shravani
JS, Shravani
9:28 PM
 <InprogressComponent inProgress={isFetching}/>
 
        <ConfirmModal
                show={showBATSConfirmModel}
                onClickOk={onClickOkSConfirmModel}
                onClickClose={() => setShowBATSConfirmModel(false)}
                confirmModelBtnName={"ok"}
                cancelModelBtnName={"Cancel"}>
                <b>Are you sure to delete the Batch Source?</b>
            </ConfirmModal>
         
<td>                         <Button varian... by JS, Shravani
JS, Shravani
9:28 PM
<td>
                        <Button variant="secondary" size="sm"
                        onClick={() => setShowBATSConfirmModel(true)}
                        >Delete </Button>
                    </td>
const [errorMessage,setErrorMessage]=React.... by JS, Shravani
JS, Shravani
9:29 PM
const [errorMessage,setErrorMessage]=React.useState("");
 
    const [showBATSConfirmModel,setShowBATSConfirmModel]=React.useState(false);
 
    const [removeBatchSource]=useDeleteBatchSourceMutation();
   
    const [showBATSConfirmModelSuccess,setShowBATSConfirmModelSuccess]=React.useState<boolean>(false);
 
    const [apiErrorResMessage, setAPIErrorMessage] = React.useState("");
has context menu

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
public class XmlToDocxController {

    @Autowired
    private PlanInfoRepository planInfoRepository;

    @PostMapping("/generate-docx-file")
    public ResponseEntity<String> generateDocxFile() {
        try {
            Optional<PlanInfo> planInfoOptional = planInfoRepository.findById(1L);

            if (planInfoOptional.isPresent()) {
                PlanInfo planInfo = planInfoOptional.get();

                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\Template.docx"));

                // Replace tags in the DOCX file
                byte[] modifiedDocument = replaceTagsInDocx(dotTemplateContent, planInfo);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, planInfo.getEvId());

                return ResponseEntity.ok().body("Generated DOCX file at: " + filePath);
            } else {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body("PlanInfo entity not found");
            }
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error generating DOCX file");
        }
    }

    private byte[] replaceTagsInDocx(byte[] docxContent, PlanInfo planInfo) throws IOException {
        String docxText = new String(docxContent, StandardCharsets.UTF_8);

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "<evId>", planInfo.getEvId(),
                "<planName>", planInfo.getPlanName()
                // Add more tag replacements as needed
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Replace the tag in the document
            docxText = docxText.replace(tag, replacement);
        }

        return docxText.getBytes(StandardCharsets.UTF_8);
    }

    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.docx";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}


The method generateDocxFiles(List<T>, String) in the type ReplaceDocxTags is not applicable for the arguments (List<ContactInfo>, String)
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
public class DocxReplaceController {

    @Autowired
    private PlanInfoRepository planInfoRepository;
    @Autowired
    private UserInfoRepository userInfoRepository;
    @Autowired
    private ContactInfoRepository contactInfoRepository;

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            List<String> filePaths = new ArrayList<>();

            List<PlanInfo> planInfos = planInfoRepository.findAll();
            List<UserInfo> userInfos = userInfoRepository.findAll();
            List<ContactInfo> contactInfos = contactInfoRepository.findAll();

            filePaths.addAll(generateDocxFiles(planInfos, "C:\\SingleTemplate.dot"));
            filePaths.addAll(generateDocxFiles(userInfos, "C:\\SingleTemplate.dot"));
            filePaths.addAll(generateDocxFiles(contactInfos, "C:\\SingleTemplate.dot"));

            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private <T extends BaseEntity> List<String> generateDocxFiles(List<T> entities, String templatePath) throws IOException {
        List<String> filePaths = new ArrayList<>();

        byte[] templateContent = Files.readAllBytes(Paths.get(templatePath));

        for (T entity : entities) {
            try {
                byte[] modifiedDocument = replaceTagsInDocx(templateContent, entity);

                String filePath = saveModifiedDocxFile(modifiedDocument, entity.getEvId());

                filePaths.add(filePath);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private <T extends BaseEntity> byte[] replaceTagsInDocx(byte[] docxContent, T entity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(docxContent);
             XWPFDocument document = new XWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, entity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private <T extends BaseEntity> void replaceTags(XWPFDocument document, T entity) {
        for (XWPFParagraph paragraph : document.getParagraphs()) {
            for (XWPFRun run : paragraph.getRuns()) {
                String text = run.getText(0);
                if (text != null) {
                    for (Map.Entry<String, String> entry : entity.getAttributes().entrySet()) {
                        text = text.replace(entry.getKey(), entry.getValue());
                    }
                    run.setText(text, 0);
                }
            }
        }
    }

    private <T extends BaseEntity> String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.docx";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}


import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;

@RestController
public class DocxReplaceController {

    @Autowired
    private XmlEntityRepository xmlEntityRepository;

    @Autowired
    private PlanInfoService planInfoService;

    @Autowired
    private UserInfoService userInfoService;

    @Autowired
    private ContactInfoService contactInfoService;

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<XmlEntity> allXmlEntities = xmlEntityRepository.findAll();

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allXmlEntities);

            return ResponseEntity.ok().body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<XmlEntity> xmlEntityList) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the data fetched from the database
        for (XmlEntity xmlEntity : xmlEntityList) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\af_plan_provision_summary_document_section_1_09.2020.dot"));

                // Replace XML tags in the DOCX file for PlanInfo, UserInfo, and ContactInfo
                byte[] modifiedDocument = replacePlanInfoTagsInDocx(dotTemplateContent, xmlEntity.getPlanInfo());
                modifiedDocument = replaceUserInfoTagsInDocx(modifiedDocument, xmlEntity.getUserInfo());
                modifiedDocument = replaceContactInfoTagsInDocx(modifiedDocument, xmlEntity.getContactInfo());

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, xmlEntity.getEvId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current xmlEntity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replacePlanInfoTagsInDocx(byte[] docContent, PlanInfo planInfo) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(docContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, planInfo);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private byte[] replaceUserInfoTagsInDocx(byte[] docContent, UserInfo userInfo) throws IOException {
        // Implement this method similar to replacePlanInfoTagsInDocx
    }

    private byte[] replaceContactInfoTagsInDocx(byte[] docContent, ContactInfo contactInfo) throws IOException {
        // Implement this method similar to replacePlanInfoTagsInDocx
    }

    private void replaceTags(HWPFDocument document, PlanInfo planInfo) {
        // Implement this method to replace tags in the document for PlanInfo
    }

    private String saveModifiedDocxFile(byte[] modifiedDocxContent, Long evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
}









package com.example.plan.xmlEntityControlller;

import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
public class DocxReplaceController {

    @Autowired
    private xmlRepo xmlEntityRepository; // Replace xmlEntityRepository with your actual repository

    @PostMapping("/generate-docx-files")
    public ResponseEntity<List<String>> generateDocxFiles() {
        try {
            // Fetch all data from the database
            List<xmlEntity> allxmlEntity = xmlEntityRepository.findAll();
            System.out.println(allxmlEntity);

            // Create a list to store the file paths of the generated DOCX files
            List<String> filePaths = generateDocxFiles(allxmlEntity);
            

            return ResponseEntity
                    .ok()
                    .body(filePaths);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    private List<String> generateDocxFiles(List<xmlEntity> xmlEntityList) throws IOException {
        // Create a list to store the file paths of the generated DOCX files
        List<String> filePaths = new ArrayList<>();

        // Iterate over the data fetched from the database
        for (xmlEntity xmlEntity : xmlEntityList) {
            try {
                // Read the DOCX template file content
                byte[] dotTemplateContent = Files.readAllBytes(Paths.get("C:\\TestXML\\af_plan_provision_summary_document_section_1_09.2020.dot"));

                // Replace XML tags in the DOCX file
                byte[] modifiedDocument = replaceXmlTagsInDocx(dotTemplateContent, xmlEntity);

                // Save the modified DOCX file
                String filePath = saveModifiedDocxFile(modifiedDocument, xmlEntity.getEvId());

                // Add the file path to the list
                filePaths.add(filePath);
            } catch (IOException e) {
                // Handle exceptions for the current xmlEntity if needed
                e.printStackTrace();
            }
        }

        return filePaths;
    }

    private byte[] replaceXmlTagsInDocx(byte[] dotContent, xmlEntity xmlEntity) throws IOException {
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(dotContent);
             HWPFDocument document = new HWPFDocument(inputStream);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            replaceTags(document, xmlEntity);
            document.write(outputStream);

            return outputStream.toByteArray();
        }
    }

    private void replaceTags(HWPFDocument document, xmlEntity planInfo) {
        Range range = document.getRange();

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "<ssmPlanNumber>", planInfo.getEvId(),
                "<ssmPlanName>", planInfo.getPlanName()
                // Add more tag replacements as needed
                
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Debugging: Print the tag and replacement value
            System.out.println("Replacing tag: " + tag);
            System.out.println("With value: " + replacement);

            // Replace the tag in the document
            range.replaceText(tag, replacement);
        }
    }
 
//        document.getParagraphs().forEach(paragraph -> {
//            // Iterate through all runs in the paragraph
//            for (XWPFRun run : paragraph.getRuns()) {
//                // Get the text content of the run
//                String text = run.getText(0);
//
//                // Debugging: Print the text and replacement value
//                System.out.println("Original Text: " + text);
//                System.out.println("Replacement Value: " + xmlEntity.getEvId());
//
//                // Replace the <ev_id></ev_id> tag with the actual evId from xmlEntity
//                if (text != null && text.contains("<plan_name></plan_name>")) {
//                    run.setText(text.replace("<plan_name></plan_name>", xmlEntity.getPlanName()), 0);
//                }
//                else if (text.contains("<ev_id></ev_id>")) {
//                    // Replace {planName} with the actual planName from xmlEntity
//                    run.setText(text.replace("<ev_id></ev_id>", xmlEntity.getEvId()), 0);
//                }
//
//                // Debugging: Print the modified text after replacement
//                System.out.println("Modified Text: " + run.getText(0));
//            }
//        });
//    }
    private String saveModifiedDocxFile(byte[] modifiedDocxContent, String evId) throws IOException {
        String filePath = "C:\\dummy xml\\" + evId + "_modified.doc";
        try (FileOutputStream fileOutputStream = new FileOutputStream(filePath)) {
            fileOutputStream.write(modifiedDocxContent);
        }
        return filePath;
    }
    }
ContactInfoEntity contactInfoEntity = new ContactInfoEntity();

            contactInfoEntity.setContactId(Long.parseLong(getElementValue(root, "contact_id")));
            contactInfoEntity.setFirstName(getElementValue(root, "first_name"));
            contactInfoEntity.setLastName(getElementValue(root, "last_name"));
            contactInfoEntity.setJobTitle(getElementValue(root, "job_title"));
            contactInfoEntity.setCompanyName(getElementValue(root, "company_name"));
            contactInfoEntity.setFirstLineMailing(getElementValue(root, "first_line_mailing"));
            contactInfoEntity.setSecondLineMailing(getElementValue(root, "scnd_line_mailing"));
            contactInfoEntity.setCity(getElementValue(root, "city"));
            contactInfoEntity.setStateCode(getElementValue(root, "state_code"));
            contactInfoEntity.setZipCode(getElementValue(root, "zip_code"));
            contactInfoEntity.setCountry(getElementValue(root, "country"));
            contactInfoEntity.setPhoneNbr(getElementValue(root, "phone_nbr"));
            contactInfoEntity.setFaxNbr(getElementValue(root, "fax_nbr"));
            contactInfoEntity.setEmailAddress(getElementValue(root, "email_address"));

            // Assuming contact_roles is a list of strings
            NodeList contactRoleNodes = root.getElementsByTagName("contact_role");
            for (int i = 0; i < contactRoleNodes.getLength(); i++) {
                contactInfoEntity.getContactRoles().add(contactRoleNodes.item(i).getTextContent());
            }

            contactInfoRepository.save(contactInfoEntity);

import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import java.util.List;

@Entity
public class ContactInfoEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long contactId;
    private String firstName;
    private String lastName;
    private String jobTitle;
    private String companyName;
    private String firstLineMailing;
    private String secondLineMailing;
    private String city;
    private String stateCode;
    private String zipCode;
    private String country;
    private String phoneNbr;
    private String faxNbr;
    private String emailAddress;

    @ElementCollection
    private List<String> contactRoles;

    // Getters and setters

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getContactId() {
        return contactId;
    }

    public void setContactId(Long contactId) {
        this.contactId = contactId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getJobTitle() {
        return jobTitle;
    }

    public void setJobTitle(String jobTitle) {
        this.jobTitle = jobTitle;
    }

    public String getCompanyName() {
        return companyName;
    }

    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }

    public String getFirstLineMailing() {
        return firstLineMailing;
    }

    public void setFirstLineMailing(String firstLineMailing) {
        this.firstLineMailing = firstLineMailing;
    }

    public String getSecondLineMailing() {
        return secondLineMailing;
    }

    public void setSecondLineMailing(String secondLineMailing) {
        this.secondLineMailing = secondLineMailing;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStateCode() {
        return stateCode;
    }

    public void setStateCode(String stateCode) {
        this.stateCode = stateCode;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getPhoneNbr() {
        return phoneNbr;
    }

    public void setPhoneNbr(String phoneNbr) {
        this.phoneNbr = phoneNbr;
    }

    public String getFaxNbr() {
        return faxNbr;
    }

    public void setFaxNbr(String faxNbr) {
        this.faxNbr = faxNbr;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public List<String> getContactRoles() {
        return contactRoles;
    }

    public void setContactRoles(List<String> contactRoles) {
        this.contactRoles = contactRoles;
    }
}


@PostMapping("/process-xml")
public ResponseEntity<String> processXmlData(@RequestBody String xmlData) {
    try {
        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dbuilder = dbfactory.newDocumentBuilder();
        Document document = dbuilder.parse(new InputSource(new StringReader(xmlData)));

        NodeList parentNodes = document.getElementsByTagName("*"); // Get all parent nodes

        for (int i = 0; i < parentNodes.getLength(); i++) {
            Element parent = (Element) parentNodes.item(i);

            switch (parent.getTagName()) {
                case "user_info":
                    saveUserInfo(parent);
                    break;
                // Add cases for other parent tags as needed
                // case "another_parent_tag":
                //     saveAnotherParentTagData(parent);
                //     break;
            }
        }

        return new ResponseEntity<>("Data saved successfully", HttpStatus.OK);
    } catch (Exception e) {
        e.printStackTrace();
        return new ResponseEntity<>("Failed to process XML data", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

private void saveUserInfo(Element parent) {
    xmlEntity xmlEntity = new xmlEntity();

    xmlEntity.setLogonId(getElementValue(parent, "logon_id"));
    xmlEntity.setLastName(getElementValue(parent, "last_name"));
    xmlEntity.setPhoneNbr(getElementValue(parent, "phone_nbr"));
    xmlEntity.setJobTitle(getElementValue(parent, "job_title"));
    xmlEntity.setMiddleName(getElementValue(parent, "middle_name"));
    xmlEntity.setAreaCode(getElementValue(parent, "area_code"));
    xmlEntity.setFirstName(getElementValue(parent, "first_name"));
    xmlEntity.setEmailAddress(getElementValue(parent, "email_address"));

    repo.save(xmlEntity);
}

// Add similar methods for other parent tags as needed

private String getElementValue(Element parseElement, String childTagName) {
    NodeList childNodes = parseElement.getElementsByTagName(childTagName);
    if (childNodes.getLength() > 0) {
        return childNodes.item(0).getTextContent();
    }
    return null;
}


private final xmlRepo repo;

@Autowired
public xmlController(xmlRepo repo) {
    this.repo = repo;
}

@GetMapping("/getxml")
public List<xmlEntity> getXmlData() {
    return repo.findAll();
}

@PostMapping("/process-xml")
public ResponseEntity<String> processXmlData(@RequestBody String xmlData) {

    try {
        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dbuilder = dbfactory.newDocumentBuilder();
        Document document = dbuilder.parse(new InputSource(new StringReader(xmlData)));

        Element root = (Element) document.getElementsByTagName("user_info").item(0);
        xmlEntity xmlentity = new xmlEntity();

        xmlentity.setLogonId(getElementValue(root, "logon_id"));
        xmlentity.setLastName(getElementValue(root, "last_name"));
        xmlentity.setPhoneNbr(getElementValue(root, "phone_nbr"));
        xmlentity.setJobTitle(getElementValue(root, "job_title"));
        xmlentity.setMiddleName(getElementValue(root, "middle_name"));
        xmlentity.setAreaCode(getElementValue(root, "area_code"));
        xmlentity.setFirstName(getElementValue(root, "first_name"));
        xmlentity.setEmailAddress(getElementValue(root, "email_address"));

        repo.save(xmlentity);

        return new ResponseEntity<>("Data saved successfully", HttpStatus.OK);
    } catch (Exception e) {
        e.printStackTrace();
        return new ResponseEntity<>("Failed to process XML data", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

private String getElementValue(Element parseElement, String childTagName) {
    NodeList childNodes = parseElement.getElementsByTagName(childTagName);
    if (childNodes.getLength() > 0) {
        return childNodes.item(0).getTextContent();
    }
    return null;
}




private final xmlRepo repo;

@Autowired
public xmlController(xmlRepo repo) {
    this.repo = repo;
}

@GetMapping("/getxml")
public List<xmlEntity> getXmlData() {
    return repo.findAll();
}

@PostMapping("/process-xml")
public ResponseEntity<String> processXmlData(@RequestBody String xmlData) {

    try {
        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dbuilder = dbfactory.newDocumentBuilder();
        Document document = dbuilder.parse(new InputSource(new StringReader(xmlData)));

        Element root = (Element) document.getElementsByTagName("user_info").item(0);
        xmlEntity xmlentity = new xmlEntity();

        xmlentity.setLogonId(getElementValue(root, "logon_id"));
        xmlentity.setLastName(getElementValue(root, "last_name"));
        xmlentity.setPhoneNbr(getElementValue(root, "phone_nbr"));
        xmlentity.setJobTitle(getElementValue(root, "job_title"));
        xmlentity.setMiddleName(getElementValue(root, "middle_name"));
        xmlentity.setAreaCode(getElementValue(root, "area_code"));
        xmlentity.setFirstName(getElementValue(root, "first_name"));
        xmlentity.setEmailAddress(getElementValue(root, "email_address"));

        repo.save(xmlentity);

        return new ResponseEntity<>("Data saved successfully", HttpStatus.OK);
    } catch (Exception e) {
        e.printStackTrace();
        return new ResponseEntity<>("Failed to process XML data", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

private String getElementValue(Element parseElement, String childTagName) {
    NodeList childNodes = parseElement.getElementsByTagName(childTagName);
    if (childNodes.getLength() > 0) {
        return childNodes.item(0).getTextContent();
    }
    return null;
}


private final xmlRepo repo;
	@Autowired
	public xmlController(xmlRepo repo) {
		this.repo = repo;
	}
	@GetMapping("/getxml")
	public List<xmlEntity> getXmlData() {
		return repo.findAll();
	}
	@PostMapping("/process-xml")
	public ResponseEntity<String> processXmlData(@RequestBody String xmlData)
	{
		
		try {
			System.out.println("erro-1");
			DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dbuilder = dbfactory.newDocumentBuilder();
			Document document = dbuilder.parse(new InputSource(new StringReader(xmlData)));
			
			
		
			Element root=(Element) document.getElementsByTagName("plan_info").item(0);
//			NodeList personList= root.getElementsByTagName("person");
			xmlEntity xmlentity = new xmlEntity();
			
				xmlentity.setEvId(getElementValue(root,"ev_id"));
			 	xmlentity.setPlanName(getElementValue(root, "plan_name"));
	            xmlentity.setIrsrlCode(getElementValue(root, "irsrl_code"));
	            xmlentity.setProvCompany(getElementValue(root, "prov_company"));
	            xmlentity.setProdId(getElementValue(root, "prod_id"));
	            xmlentity.setStatusCode(getElementValue(root, "status_code"));
	            xmlentity.setDpDateTime(getElementValue(root, "dpdate_time"));
	            xmlentity.setRolloverInd(getElementValue(root, "rollover_ind"));
	            xmlentity.setGaId(getElementValue(root, "ga_id"));
	            xmlentity.setClientName(getElementValue(root, "client_name"));
	            xmlentity.setFirstLineMailing(getElementValue(root, "first_line_mailing"));
	            xmlentity.setScndLineMailing(getElementValue(root, "scnd_line_mailing"));
	            xmlentity.setCity(getElementValue(root, "city"));
	            xmlentity.setStateCode(getElementValue(root, "state_code"));
	            xmlentity.setZipCode(getElementValue(root, "zip_code"));
	            xmlentity.setCountry(getElementValue(root, "country"));
	            xmlentity.setInternalComplianceInd(getElementValue(root, "internal_compliance_ind"));
	            xmlentity.setPlanAnnivDate(getElementValue(root, "plan_anniv_date"));
	            xmlentity.setEstNumberOfParticipants(getElementValue(root, "est_number_of_participants"));
	            xmlentity.setEstPlanAssets(getElementValue(root, "est_plan_assets"));
	            xmlentity.setEstImplementationDate(LocalDate.parse(getElementValue(root, "est_implementation_date")));
	            xmlentity.setSubsetCashCode(getElementValue(root, "subset_cash_code"));
	            xmlentity.setClientEntityType(getElementValue(root, "client_entity_type"));
	            xmlentity.setTpaFirmId(getElementValue(root, "tpa_firm_id"));
	            System.out.println("erro2");
	            repo.save(xmlentity);

			return new ResponseEntity<String>("data success",HttpStatus.OK);
		}catch(Exception e)
		{
			e.printStackTrace();
			return new ResponseEntity<String>("failed",HttpStatus.INTERNAL_SERVER_ERROR);
		}
			
		}
		private String getElementValue(Element parseElement,String childTagName) {
			NodeList childnodes = parseElement.getElementsByTagName(childTagName);
			if(childnodes.getLength()>0) {
				return childnodes.item(0).getTextContent();
			}
			return null;
		}


private String type;
    private String logonId;
    private String lastName;
    private String phoneNbr;
    private String jobTitle;
    private String middleName;
    private String areaCode;
    private String firstName;
    private String emailAddress;

private void replaceTags(HWPFDocument document, PlanInfo planInfo) {
        Range range = document.getRange();

        // Define your tag replacements
        Map<String, String> tagReplacements = Map.of(
                "{evId}", planInfo.getEvId(),
                "{planName}", planInfo.getPlanName(),
                // Add more tag replacements as needed
                "{anotherTag}", planInfo.getAnotherField()
        );

        // Iterate through the tag replacements
        for (Map.Entry<String, String> entry : tagReplacements.entrySet()) {
            String tag = entry.getKey();
            String replacement = entry.getValue();

            // Debugging: Print the tag and replacement value
            System.out.println("Replacing tag: " + tag);
            System.out.println("With value: " + replacement);

            // Replace the tag in the document
            range.replaceText(tag, replacement);
        }
    }
 

	



    PlanPremier-TPA
Plan Provision Summary for:
<ssmPlanName> <ssmPlanNumber>

 


 	
Plan Provision Summary
<ssmPlanName>
<ssmPlanNumber>
		

The purpose of this Plan Provision Summary is to confirm existing plan specifications transferred 



	



TPA General Plan Information
	                                                                             
Is this an ERISA Plan?                                               
	<ssmblner~Y> Yes
<ssmblner~N> No  

Is this a Union plan? 	  <ssmblnUnionPlan> Yes
  <ssmblnUnionPlan> No
<ssmPlanName> Original Plan effective Date:                        
	<ssmOrigPlanEffDate>







Rollovers
Indicate the rollover types allowed by the plan:    

Are 401 rollovers allowed by the plan?
	<ssmbln401Roll~Y> Yes	
<ssmbln401Roll~N> No  
Are IRA rollovers allowed by the plan?
 	<ssmblnIRARoll~Y> Yes	
<ssmblnIRARoll~N> No  
Are Roth rollovers allowed by the plan?
 	<ssmblnRothRoll~Y> Yes	
<ssmblnRothRoll~N> No  
Are 403b rollovers allowed by the plan?
 	<ssmbln403bRoll~Y> Yes	
<ssmbln403bRoll~N> No  
Are 457 rollovers allowed by the plan?
 	<ssmbln457Roll~Y> Yes	
<ssmbln457Roll~N> No  
Are after-tax rollovers allowed by the plan?
 	<ssmblnATKRoll~Y> Yes	
<ssmblnATKRoll~N> No 



 401(k) Contributions

 Employee elective deferrals allowed by the Plan?                                                       	<ssmblnBEF~Y> Yes	
<ssmblnBEF~N> No 	

Is the plan a Safe Harbor 401(k)?                                                                                            	<ssmblnSHPlan~Y> Yes	
<ssmblnSHPlan~N> No  	

Will American Funds be tracking deferrals?                                                                                       	  <ssmblnAFDefTrack> Yes
  <ssmblnAFDefTrack> No
How do you want the deferrals tracked?
 
Percentage                                                                                                                                                                          
 
Minimum deferral percentage
<ssmMinDefPerBTK> %
Maximum deferral percentage
<ssmMaxDefPerBTK>%
Dollars                                                                                                                                                                                 
 
Minimum annual deferral amount
$<ssmMinDefDolBTK>
Maximum annual deferral amount
<ssmMaxDefDolBTK>
Dollars and Percentage                                                                                                                                                               
Minimum annual deferral amount 
$<ssmMinDefDolBTK>	Minimum deferral percentage
<ssmMinDefPerBTK>%
Maximum annual deferral amount 
<ssmMaxDefDolBTK>	Maximum deferral percentage
<ssmMaxDefPerBTK> %




 401(k) Catch-up Contributions

Are Catch-up elections allowed?                                                                       	<ssmblnCatchUp~Y> Yes  	
<ssmblnCatchUp~N> No	

Does your payroll software require catch-ups to be tracked separately?                                                                                        	<ssmblnCatchUptrack~Y> Yes  	
<ssmblnCatchUptrack~N> No	

How should be tracked?
 	  <ssmCatchUpDefTrackMethod>




Auto-Enrollment Feature

Does the Plan utilize an automatic enrollment feature?   	<ssmblnautoenroll~Y>  Yes	
<ssmblnautoenroll~N>  No  	

Will American Funds track automatic enrollment?   	<ssmblnAFautoenrolltrack~Y> Yes 	
<ssmblnAFautoenrolltrack~N> No
	

Is this an existing Automatic Enrollment feature?  	<ssmblnexistautoenroll~Y> Yes   	
<ssmblnexistautoenroll~N> No	

Do you want to have American Funds mail annual Automatic Enrollment notices to participants?	<ssmblnAFannNotification~Y> Yes   	
<ssmblnAFannNotification~N> No	

Type of Automatic Enrollment Arrangement used	<ssmblnQACAType~Y> QACA 
<ssmblnEACA~Y>  EACA
<ssmblnACA~Y> ACA



 




QACA Provisions

What is the beginning default auto-enroll percentage (3% - 10%)	  <ssmQACAdefautoenrollPer> %   
Will the plan increase the default deferral percentage?
Note: Scheduled deferral increase are required if the beginning default auto enroll is less than 6%.	<ssmblnQACAdefinc~Y> Yes	
<ssmblnQACAdefinc~N> No	

What percentage will the automatic deferral increase annually?   
Note: Increases will be applied at the beginning of each plan year.  For the first increase, this will occur at the beginning of the plan year once the participant is at the initial default rate for a minimum of 12 months.	  <ssmQACAannualDefInc> %  
Maximum automatic deferral percentage:	  <ssmQACAmaxAutoDef>%  
Safe Harbor election method:   	  <ssmQACASHelection>
QACA Vesting schedule:	  <ssmQACAVestingSch>
Please describe your Vesting Schedule:	  <ssmQACAVestingSchDesc>
Can forfeitures be used to pay plan expenses?	<ssmblnQACAForfPayExp~Y> Yes    
<ssmblnQACAForfPayExp~N> No  

Can forfeitures be used to reallocate?	<ssmblnQACAForfRealloc~Y> Yes 
<ssmblnQACAForfRealloc~N> No  

Can forfeitures be used to reduce employer contributions?	<ssmblnQACARedERCont~Y> Yes    
<ssmblnQACARedERCont~N> No  

Can forfeitures be used for the same money type as the QACA or all employer monies?	  <ssmQACAForfRedMethod>  
Will the plan allow the permissible withdrawal election?  
Note: QDIA election applies to QACA if the 90 day permissible withdrawals is permitted.	<ssmblnPermWD~Y> Yes	
<ssmblnPermWD~N> No	

How will the QACA provision be applied?  Not applicable if Automatic Enrollment feature was previously existing
<ssmblnQACAapply~Option A>	Option A: applies to all participants regardless of any prior salary reduction agreement unless and until they make a contrary election after the Automatic Deferral Effective Date.
<ssmblnQACAapply~Option B>	Option B: only to participants whose current salary reduction agreement is less than the automatic deferral percentage. 
<ssmblnQACAapply~Option C>	Option C: applies only to participants who do not have an existing salary reduction agreement in effect.


  
EACA Provisions

What is the beginning default auto-enroll percentage (3% - 10%)	  <ssmEACAdefautoenroll>%   
Will the plan increase the default deferral percentage?	<ssmblnEACAdefinc~Y> Yes	
<ssmblnEACAdefinc~N> No	

What percentage will the automatic deferral increase annually?   
Note: Increases will applied at the beginning of each plan year.	  <ssmEACAannualDefInc>%
Maximum automatic deferral percentage:	  <ssmEACAmaxAutoDef>%        
How will the EACA provision be applied?  Not applicable if Automatic Enrollment Feature was previously existing
Note: To take advantage of the 6 month extension for discrimination testing, the EACA provision must apply to all existing participants within the plan (defined as Covered Employees by the IRS).
<ssmblnEACAapply~Option A>	Option A: applies to all participants regardless of any prior salary reduction agreement unless and until they make a contrary election after the Automatic Deferral Effective Date.
<ssmblnEACAapply~Option B>	Option B - only to participants whose current salary reduction agreement is less than the automatic deferral percentage.     
<ssmblnEACAapply~Option C>	Option C - only to those participants who do not have an existing salary reduction agreement in effect     
<ssmblnEACAapply~Option D>	Option D: applies only to those employees who become eligible on or after the following date:  <ssmEACAapplydate> (Note: option D is only available if you have a record of all affirmative elections from all eligible employees prior to the automatic deferral effective date.  The 6 month extension for discrimination testing will not apply if this provision D is selected. 
 


ACA Provisions

What is the beginning default auto-enroll percentage (1% - 10%)	  <ssmACAdefAutoEnroll>%   
Will the plan increase the default deferral percentage?	<ssmblnACAdefinc~Y> Yes	
<ssmblnACAdefinc~N> No  	

What percentage will the automatic deferral increase annually?   	  <ssmACAannualDefinc>%  
Maximum automatic deferral percentage:	  <ssmACAmaxAutoDefPer>%        
How will the ACA provision be applied?  Not applicable if the Automatic Enrollment feature was previously existing.
The Permissible withdrawal election is not allowed under ACA.
<ssmblnACAapply~Option A>	Option A: applies to all participants regardless of any prior salary reduction agreement unless and until they make a contrary election after the Automatic Deferral Effective Date.
<ssmblnACAapply~Option B>	Option B: only to participants whose current salary reduction agreement is less than the automatic deferral percentage.
<ssmblnACAapply~Option C>	Option C: applies only to participants who do not have an existing salary reduction agreement in effect.
<ssmblnACAapply~Option D>	Option D: apply only to those employees who become eligible on or after the following date:  <ssmACAapplydate>  (NoteL option D is only available if you have a record of all affirmative elections from all eligible employees prior to the automatic deferral effective date.

Please note:  Automatic Enrollment requires an initial notice be provided to participants prior to their participation in the plan.  American Funds can provide you with a sample notice that you can customize and provide to your participants. 





Match Contributions

Will the plan make matching contributions?                                          	<ssmblnMatch~Y> Yes
<ssmblnMatch~N> No

Is the matching formula a fixed or discretionary contribution? 
 	  <ssmebmatchformula> 
Will the participants be restricted from directing how the match is invested?                                                                                                         	<ssmblnMatchERDirected~Y> Yes    
<ssmblnMatchERDirected~N> No  

Vesting Schedule?                                                                                      	<ssmMatchVestingSch>
Please describe your Vesting Schedule:                                               	<ssmMatchVestingSchDesc> 

Can forfeitures be used to pay Plan expenses?                         
 	<ssmblnMatchForfPayExp~Y> Yes    
<ssmblnMatchForfPayExp~N> No  

Can forfeitures be reallocated to participants in excess of existing Match contribution?                                                                               
 	<ssmblnMatchForfRealloc~Y> Yes 
<ssmblnMatchForfRealloc~N> No  

Can forfeiture money be used to reduce the employers contributions?                                                                                                   	<ssmblnMatchRedERCont~Y> Yes    
<ssmblnMatchRedERCont~N> No  

Can forfeitures be used for match only or all employer monies?                                                                                    	  <ssmMatchForfRedMethod>  
Allocation conditions of Employer Matching contributions?	  <ssmblnMatchAllocCond~Y> Yes
  <ssmblnMatchAllocCond~N> No 
Must be employed on the last day of the plan year OR have more than 500 hours of service for the plan year?	  <ssmblnMatchLDor500~Y> Yes
  <ssmblnMatchLDor500~N> No
Must be employed on the last day of the plan year?	  <ssmblnMatchLastDay~Y> Yes
  <ssmblnMatchLastDay~N> No
Must be credited with hours of service?	  <ssmblnMatchHourServ~Y> Yes
  <ssmblnMatchHourServ~N> No
What are the minimum credit hours of service?	  <ssmMatchMinServ>
The Match allocation conditions will not apply if the participant:	  <ssmMatchDeathExclude>
  <ssmMatchNRAExclude>
  <ssmMatchDisabledExclude>




Profit Sharing Contributions

Does the Plan allow for profit sharing contributions?                  
 	<ssmblnPS~Y> Yes  	
<ssmblnPS~N> No	

Will the participants be restricted from directing how the profit sharing is invested?                                                                           
 	<ssmblnPSERDirected~Y> Yes  	
<ssmblnPSERDirected~N> No	

Vesting schedule?                                                                                	<ssmPSVestingSch>
Please describe your Vesting Schedule:                                          
 	<ssmPSVestingSchDesc> 
Can forfeitures be used to pay plan expenses?                                                   	<ssmblnPSForfPayExp~Y> Yes	
<ssmblnPSForfPayExp~N>No  	

Can forfeitures be used to reallocate?                                            
 	<ssmblnPSForfRealloc~Y> Yes 	
<ssmblnPSForfRealloc~N> No  	

Can forfeiture money be used to reduce the employers contributions?                                                                           
 	<ssmblnPSRedERCont~Y> Yes    	
<ssmblnPSRedERCont~N> No  	

Can forfeitures be used for profit sharing only or all employer monies?                                                                
 	  <ssmPSForfRedMethod>  

Allocation conditions of Profit Sharing contributions?	  <ssmblnPSAllocCond~Y> Yes
  <ssmblnPSAllocCond~N> No
Must be employed on the last day of the plan year OR have more than 500 hours of service for the plan year?	  <ssmblnPSAllocCondLD500~Y> Yes
  <ssmblnPSAllocCondLD500~N> No
Must be employed on the last day of the plan year?	  <ssmblnPSAllocCondLD~Y> Yes
  <ssmblnPSAllocCondLD~N> No
Must be credited with hours of service?	  <ssmblnPSAllocCondHrsServ~Y> Yes
  <ssmblnPSAllocCondHrsServ~N> No
What are the minimum credit hours of service?	  <ssmPSAllocCondMinHrsServ>
The Profit Sharing allocation conditions will not apply if the participant:	  <ssmPSDeathExclude>
  <ssmPSNRAExclude>
  <ssmPSDisabledExclude>




Money Purchase Contributions

Does the Plan allow for money purchase contributions?          
 	<ssmblnMP~Y> Yes
<ssmblnMP~N> No  

What is the Money Purchase contribution formula that should be displayed in the enrollment guide? 
 	<ssmebmoneypurchase>
Will the participants be restricted from directing how the money purchase is invested:
 	<ssmblnMPERDirected~Y> Yes
<ssmblnMPERDirected~N> No

Vesting schedule?  
 	<ssmMPVestingSch>
Please describe your Vesting Schedule  
 	<ssmMPVestingSchDesc> 
Can forfeitures be used to pay plan expenses?    
 	<ssmblnMPForfPayExp~Y> Yes  
<ssmblnMPForfPayExp~N> No  

Can forfeitures be used to reallocate?    
 	<ssmblnMPForfRealloc~Y> Yes   
<ssmblnMPForfRealloc~N> No  

Can forfeiture money be used to reduce the employers contributions?    
 	<ssmblnMPRedERCont~Y> Yes  
<ssmblnMPRedERCont~N> No  

Allocation conditions of Money Purchase contributions?	  <ssmblnMPAllocCond~Y> Yes
  <ssmblnMPAllocCond~N> No 
Must be employed on the last day of the plan year OR have more than 500 hours of service for the plan year?	  <ssmblnMPAllocCondLD500~Y> Yes
  <ssmblnMPAllocCondLD500~N> No
Must be employed on the last day of the plan year?	  <ssmblnMPAllocCondLD~Y> Yes
  <ssmblnMPAllocCondLD~N> No
Must be credited with hours of service?	  <ssmblnMPAllocCondHrsServ~Y> Yes
  <ssmblnMPAllocCondHrsServ~N> No
What are the minimum credit hours of service?	  <ssmMPAllocCondMinHrsServ>
The Money Purchase allocation conditions will not apply if the participant:	  <ssmMPDeathExclude>
  <ssmMPNRAExclude>
  <ssmMPDisabledExclude>




After-Tax Contributions

Are after-tax contributions allowed by the Plan?                         
 	<ssmblnATK~Y> Yes
<ssmblnATK~N> No  

How do you want after-tax contributions tracked?                         
 	  <ssmAftTaxDef>
Is there a minimum after-tax percentage allowed by the Plan? 
 	  <ssmATKMinPer>%
Is there a maximum after-tax percentage allowed by the Plan? 
 	  <ssmATKMaxPer>%

Is there a minimum after-tax amount allowed by the Plan? 
Page 3	  $<ssmATKMinDol>
 
Is there a maximum after-tax amount allowed by the Plan? 
Page 3	  $<ssmATKMaxDol>





Roth Contributions

Are Roth contributions allowed by the plan?                      
 	<ssmblnRoth~Y> Yes
<ssmblnRoth~N> No  

Does the plan allow Roth Corrective distributions?       
 	<ssmblnRothCorrDist~Y> Yes
<ssmblnRothCorrDist~N> No   

Does the plan allow In Plan Roth Rollovers?                   
 	<ssmblnInPlanRothRollover~Y> Yes
<ssmblnInPlanRothRollover~N> No  

Does the plan allow In Plan Roth Transfers?                     
 	<ssmblnInPlanRothTransfer~Y> Yes
<ssmblnInPlanRothTransfer~N> No

Are there any other distributable events applicable to In Plan Roth Rollovers that are not otherwise allowable in-service distributions?                                                                  
 	<ssmblnInPlanRothOtherDist~Y> Yes
<ssmblnInPlanRothOtherDist~N> No

Please describe if you have any restrictions on In Plan Roth Rollovers/Transfers (e.g., 100% vesting requirements, money source limitations, etc.), or input "None" in following text box:
 	<ssmebInPlanRothRestDesc>
Confirm the money type order for corrective distributions: 
 	<ssmRothCorrDistWDOrder>




Additional Money Types


Does the plan allow for a non-QACA Safe Harbor Match?         
 	  <ssmblnNon_QACA_Safe_Harbor_Match~Y> Yes
  <ssmblnNon_QACA_Safe_Harbor_Match~N> No
Does the plan allow for a non-QACA Safe Harbor Profit Sharing?                                                                               	  <ssmblnNon_QACA_Safe_Harbor_Profit_Sharing~Y> Yes
  <ssmblnNon_QACA_Safe_Harbor_Profit_Sharing~N> No
Does the plan allow for a Qualified Matching Contribution (QMAC)? 
 	  <ssmblnQMAC~Y> Yes
  <ssmblnQMAC~N> No
Does the plan allow for a Qualified Non-Elective Contribution (QNEC)?                                                                                    	  <ssmblnQNEC~Y> Yes
  <ssmblnQNEC~N> No



Fatal Error] :3:1: Content is not allowed in prolog.
org.xml.sax.SAXParseException; lineNumber: 3; columnNumber: 1; Content is not allowed in prolog.
	at java.xml/com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:262)


planInfo.setEvId(getChildElementValue(planInfoElement, "ev_id"));
            planInfo.setPlanName(getChildElementValue(planInfoElement, "plan_name"));
            planInfo.setIrsrlCode(getChildElementValue(planInfoElement, "irsrl_code"));
            planInfo.setProvCompany(getChildElementValue(planInfoElement, "prov_company"));
            planInfo.setProdId(getChildElementValue(planInfoElement, "prod_id"));
            planInfo.setStatusCode(getChildElementValue(planInfoElement, "status_code"));
            planInfo.setDpDateTime(getChildElementValue(planInfoElement, "dpdate_time"));
            planInfo.setRolloverInd(getChildElementValue(planInfoElement, "rollover_ind"));
            planInfo.setGaId(getChildElementValue(planInfoElement, "ga_id"));
            planInfo.setClientName(getChildElementValue(planInfoElement, "client_name"));
            planInfo.setFirstLineMailing(getChildElementValue(planInfoElement, "first_line_mailing"));
            planInfo.setScndLineMailing(getChildElementValue(planInfoElement, "scnd_line_mailing"));
            planInfo.setCity(getChildElementValue(planInfoElement, "city"));
            planInfo.setStateCode(getChildElementValue(planInfoElement, "state_code"));
            planInfo.setZipCode(getChildElementValue(planInfoElement, "zip_code"));
            planInfo.setCountry(getChildElementValue(planInfoElement, "country"));
            planInfo.setInternalComplianceInd(getChildElementValue(planInfoElement, "internal_compliance_ind"));
            planInfo.setPlanAnnivDate(getChildElementValue(planInfoElement, "plan_anniv_date"));
            planInfo.setEstNumberOfParticipants(Integer.parseInt(getChildElementValue(planInfoElement, "est_number_of_participants")));
            planInfo.setEstPlanAssets(Long.parseLong(getChildElementValue(planInfoElement, "est_plan_assets")));
            planInfo.setEstImplementationDate(LocalDate.parse(getChildElementValue(planInfoElement, "est_implementation_date")));
            planInfo.setSubsetCashCode(getChildElementValue(planInfoElement, "subset_cash_code"));
            planInfo.setClientEntityType(getChildElementValue(planInfoElement, "client_entity_type"));
            planInfo.setTpaFirmId(getChildElementValue(planInfoElement, "tpa_firm_id"));

            planInfoRepository.save(planInfo)
;


024-02-11T23:17:36.301-07:00  INFO 9500 --- [nio-8081-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field "db_key" (class newxml.PlanInfo), not marked as ignorable (24 known properties: "subsetCashCode", "estNumberOfParticipants", "dpDateTime", "clientEntityType", "city", "evId", "rolloverInd", "irsrlCode", "prodId", "planAnnivDate", "planName", "gaId", "clientName", "stateCode", "statusCode", "firstLineMailing", "zipCode", "scndLineMailing", "estPlanAssets", "provCompany", "country", "tpaFirmId", "internalComplianceInd", "estImplementationDate"])
 at [Source: (StringReader); line: 3, column: 93] (through reference chain: newxml.PlanInfo["db_key"])
	at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:61)
	at com.fasterxml.jackson.databind.DeserializationContext.handleUnknownProperty(DeserializationContext.java:1138)
	at com.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:2224)
	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1709)
	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1687)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:320)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:177)
	at com.fasterxml.jackson.dataformat.xml.deser.XmlDeserializationContext.readRootValue(XmlDeserializationContext.java:91)
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4825)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3772)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3740)
	at newxml.PlanInfoController.createPlanInfoFromXml(PlanInfoController.java:51)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:261)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:189)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:917)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:829)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.s


package newxml;

import java.time.LocalDate;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class PlanInfo {

    @Id
    private String evId;
    private String planName;
    private String irsrlCode;
    private String provCompany;
    private String prodId;
    private String statusCode;
    private String dpDateTime;
    private String rolloverInd;
    private String gaId;
    private String clientName;
    private String firstLineMailing;
    private String scndLineMailing;
    private String city;
    private String stateCode;
    private String zipCode;
    private String country;
    private String internalComplianceInd;
    private String planAnnivDate;
    private int estNumberOfParticipants;
    private long estPlanAssets;
    private LocalDate estImplementationDate;
    private String subsetCashCode;
    private String clientEntityType;
    private String tpaFirmId;
	
    
    
    public String getEvId() {
        return evId;
    }

    public void setEvId(String evId) {
        this.evId = evId;
    }
	public String getPlanName() {
		return planName;
	}
	public void setPlanName(String planName) {
		this.planName = planName;
	}
	public String getIrsrlCode() {
		return irsrlCode;
	}
	public void setIrsrlCode(String irsrlCode) {
		this.irsrlCode = irsrlCode;
	}
	public String getProvCompany() {
		return provCompany;
	}
	public void setProvCompany(String provCompany) {
		this.provCompany = provCompany;
	}
	public String getProdId() {
		return prodId;
	}
	public void setProdId(String prodId) {
		this.prodId = prodId;
	}
	public String getStatusCode() {
		return statusCode;
	}
	public void setStatusCode(String statusCode) {
		this.statusCode = statusCode;
	}
	public String getDpDateTime() {
		return dpDateTime;
	}
	public void setDpDateTime(String dpDateTime) {
		this.dpDateTime = dpDateTime;
	}
	public String getRolloverInd() {
		return rolloverInd;
	}
	public void setRolloverInd(String rolloverInd) {
		this.rolloverInd = rolloverInd;
	}
	public String getGaId() {
		return gaId;
	}
	public void setGaId(String gaId) {
		this.gaId = gaId;
	}
	public String getClientName() {
		return clientName;
	}
	public void setClientName(String clientName) {
		this.clientName = clientName;
	}
	public String getFirstLineMailing() {
		return firstLineMailing;
	}
	public void setFirstLineMailing(String firstLineMailing) {
		this.firstLineMailing = firstLineMailing;
	}
	public String getScndLineMailing() {
		return scndLineMailing;
	}
	public void setScndLineMailing(String scndLineMailing) {
		this.scndLineMailing = scndLineMailing;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public String getStateCode() {
		return stateCode;
	}
	public void setStateCode(String stateCode) {
		this.stateCode = stateCode;
	}
	public String getZipCode() {
		return zipCode;
	}
	public void setZipCode(String zipCode) {
		this.zipCode = zipCode;
	}
	public String getCountry() {
		return country;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public String getInternalComplianceInd() {
		return internalComplianceInd;
	}
	public void setInternalComplianceInd(String internalComplianceInd) {
		this.internalComplianceInd = internalComplianceInd;
	}
	public String getPlanAnnivDate() {
		return planAnnivDate;
	}
	public void setPlanAnnivDate(String planAnnivDate) {
		this.planAnnivDate = planAnnivDate;
	}
	public int getEstNumberOfParticipants() {
		return estNumberOfParticipants;
	}
	public void setEstNumberOfParticipants(int estNumberOfParticipants) {
		this.estNumberOfParticipants = estNumberOfParticipants;
	}
	public long getEstPlanAssets() {
		return estPlanAssets;
	}
	public void setEstPlanAssets(long estPlanAssets) {
		this.estPlanAssets = estPlanAssets;
	}
	public LocalDate getEstImplementationDate() {
		return estImplementationDate;
	}
	public void setEstImplementationDate(LocalDate estImplementationDate) {
		this.estImplementationDate = estImplementationDate;
	}
	public String getSubsetCashCode() {
		return subsetCashCode;
	}
	public void setSubsetCashCode(String subsetCashCode) {
		this.subsetCashCode = subsetCashCode;
	}
	public String getClientEntityType() {
		return clientEntityType;
	}
	public void setClientEntityType(String clientEntityType) {
		this.clientEntityType = clientEntityType;
	}
	public String getTpaFirmId() {
		return tpaFirmId;
	}
	public void setTpaFirmId(String tpaFirmId) {
		this.tpaFirmId = tpaFirmId;
	}
	@Override
	public String toString() {
		return "PlanInfo [ evId=" + evId + ", planName=" + planName + ", irsrlCode=" + irsrlCode
				+ ", provCompany=" + provCompany + ", prodId=" + prodId + ", statusCode=" + statusCode + ", dpDateTime="
				+ dpDateTime + ", rolloverInd=" + rolloverInd + ", gaId=" + gaId + ", clientName=" + clientName
				+ ", firstLineMailing=" + firstLineMailing + ", scndLineMailing=" + scndLineMailing + ", city=" + city
				+ ", stateCode=" + stateCode + ", zipCode=" + zipCode + ", country=" + country
				+ ", internalComplianceInd=" + internalComplianceInd + ", planAnnivDate=" + planAnnivDate
				+ ", estNumberOfParticipants=" + estNumberOfParticipants + ", estPlanAssets=" + estPlanAssets
				+ ", estImplementationDate=" + estImplementationDate + ", subsetCashCode=" + subsetCashCode
				+ ", clientEntityType=" + clientEntityType + ", tpaFirmId=" + tpaFirmId + "]";
	}

    // Constructors, getters, setters...
    
}
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
</build>
<dependencies>
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.13.0</version>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi</artifactId>
        <version>5.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
        <version>5.0.0</version>
    </dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
	

// DataTable.js

import React, { useState, useEffect } from 'react';

const DataTable = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    // Fetch data from API when the component mounts
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      // Replace 'your-api-endpoint' with the actual API endpoint
      const response = await fetch('http://localhost:8085/');
      const result = await response.json();
      setData(result); // Set the fetched data to the state
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  return (
    <div>
      <h1>Data Table</h1>
      <table>
        <thead>
          <tr>
            {/* Map column headers based on the structure of your data */}
            {Object.keys(data[0] || {}).map((header, index) => (
              <th key={index}>{header}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {/* Map data rows */}
          {data.map((row, rowIndex) => (
            <tr key={rowIndex}>
              {/* Map row values based on the structure of your data */}
              {Object.values(row).map((value, columnIndex) => (
                <td key={columnIndex}>{value}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default DataTable;


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class XmlDataParser {

    public static void main(String[] args) throws Exception {
        // Load XML file
        File xmlFile = new File("yourXMLfile.xml");
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document document = dBuilder.parse(xmlFile);
        document.getDocumentElement().normalize();

        // Map to store data
        Map<String, Map<String, String>> parentDataMap = new HashMap<>();

        // Get all parent elements
        NodeList parentElements = document.getElementsByTagName("parentElementName");

        for (int i = 0; i < parentElements.getLength(); i++) {
            Node parentElementNode = parentElements.item(i);

            if (parentElementNode.getNodeType() == Node.ELEMENT_NODE) {
                Element parentElement = (Element) parentElementNode;

                // Map to store child element data
                Map<String, String> childDataMap = new HashMap<>();

                // Get all child elements inside the parent element
                NodeList childElements = parentElement.getChildNodes();

                for (int j = 0; j < childElements.getLength(); j++) {
                    Node childNode = childElements.item(j);

                    if (childNode.getNodeType() == Node.ELEMENT_NODE) {
                        Element childElement = (Element) childNode;
                        String elementName = childElement.getNodeName();
                        String elementValue = childElement.getTextContent();

                        // Store child element data in the inner map
                        childDataMap.put(elementName, elementValue);
                    }
                }

                // Store the inner map in the outer map with parent element name as the key
                parentDataMap.put(parentElement.getNodeName(), childDataMap);
            }
        }

        // Print or use the resulting data map as needed
        System.out.println(parentDataMap);
    }
}


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class XmlDataToObject {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            File xmlFile = new File("yourXMLfile.xml");
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document document = dBuilder.parse(xmlFile);
            document.getDocumentElement().normalize();

            // Create a Map to store element name and data
            Map<String, String> dataMap = new HashMap<>();

            // Specify the element name you want to retrieve
            String targetElement = "yourElement";

            // Get the NodeList of elements with the specified name
            NodeList nodeList = document.getElementsByTagName(targetElement);

            // Iterate through the NodeList and store data in the map
            for (int i = 0; i < nodeList.getLength(); i++) {
                Element element = (Element) nodeList.item(i);
                String elementName = element.getNodeName();
                String elementData = element.getTextContent();
                dataMap.put(elementName, elementData);
            }

            // Print or use the dataMap as needed
            System.out.println(dataMap);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}




<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.0</version> <!-- Use the latest version available -->
</dependency>

import com.fasterxml.jackson.databind.ObjectMapper;

// Assuming your data is in a Map<String, String> called extractedData
ObjectMapper objectMapper = new ObjectMapper();
String jsonData = objectMapper.writeValueAsString(extractedData);


NodeList nodeList = document.getElementsByTagName("yourElement");
String data = nodeList.item(0).getTextContent();

DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document document = builder.parse(new File("yourXMLfile.xml"));
  export const Foo = () => (
  <form>
    <div className="form-row">
      <div className="form-group col-md-4">
        <input type="text" className="form-control" id="planYearEnds" />
        <label htmlFor="planYearEnds">Plan Year Ends</label>
      </div>
      <div className="form-group col-md-4">
        <button
          type="button"
          className="btn btn-secondary"
          id="servicesAndBilling"
        >
          Services And Billing
        </button>
      </div>
      <div className="form-group col-md-4">
        <button type="button" className="btn btn-secondary" id="pyeTesting1">
          PYE Testing
        </button>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-2">
        <label>YEAR END INFO</label>
      </div>
      <div className="form-group col-md-2">
        <label>COUNTS</label>
      </div>
      <div className="form-group col-md-8">
        <label>5500 INFO</label>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="yearEnd" />
        <label htmlFor="yearEnd">Year End</label>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="eligibleEmployees" />
        <label htmlFor="eligibleEmployees">Eligible Employees</label>
      </div>
      <div className="form-group col-md-2">
        <button type="button" className="btn btn-primary" id="xml5500">
          5500 XML
        </button>
        <button type="button" className="btn btn-primary" id="email5500">
          5500 Email
        </button>
      </div>
      <div className="form-group col-md-3">
        <input type="text" className="form-control" id="type5500" />
        <label htmlFor="type5500">5500 Type</label>
      </div>
      <div className="form-group col-md-3">
        <input type="text" className="form-control" id="filingStatus" />
        <label htmlFor="filingStatus">Filing Status</label>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="yearStart" />
        <label htmlFor="yearStart">Year Start</label>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="totalEmployees" />
        <label htmlFor="totalEmployees">Total Employees</label>
      </div>
      <div className="form-group col-md-2">
        <button type="button" className="btn btn-primary" id="yeq">
          YEQ
        </button>
        <button type="button" className="btn btn-primary" id="dfvcEmail">
          DFVC Email
        </button>
      </div>
      <div className="form-group col-md-3">
        <input type="text" className="form-control" id="signer5500" />
        <label htmlFor="signer5500">5500 Signer</label>
        <div className="form-check">
          <label className="form-check-label">
            <input
              className="form-check-input"
              id="partial5500"
              type="checkbox"
            />{" "}
            5500 Partial
          </label>
        </div>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="taxYear" />
        <label htmlFor="taxYear">Tax Year</label>
      </div>
      <div className="form-group col-md-2"></div>
      <div className="form-group col-md-2">
        <button type="button" className="btn btn-primary" id="resetPortalUser">
          Reset Portal User
        </button>
        <button type="button" className="btn btn-primary" id="addCompanyToFTW">
          Add Company to FTW
        </button>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="pointsValue" />
        <label htmlFor="pointsValue">Points Value</label>
      </div>
      <div className="form-group col-md-2">
        <button
          type="button"
          className="btn btn-primary"
          id="contributionSources"
        >
          Contribution Sources
        </button>
        <button type="button" className="btn btn-primary" id="moveItemsToPSC">
          Move Items To PSC
        </button>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <label>SERVICES</label>
      </div>
      <div className="form-group col-md-6">
        <label>FORFEITURE INFO</label>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="planDocument"
            />{" "}
            Plan Document
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="yearEndComplianceTesting"
            />{" "}
            Year End Compliance Testing
          </label>
        </div>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="matchForfType" />
        <label htmlFor="matchForfType">Match Forf Type</label>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="matchForfAmt" />
        <label htmlFor="matchForfAmt">Match Forf Amt</label>
      </div>
      <div className="form-group col-md-2">
        <button type="button" className="btn btn-primary" id="folder">
          Folder
        </button>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="midYrComplianceTesting"
            />{" "}
            Mid Yr Compliance Testing
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="preparation5500"
            />{" "}
            5500 Preparation
          </label>
        </div>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="psForfType" />
        <label htmlFor="psForfType">P/S Forf Type</label>
      </div>
      <div className="form-group col-md-2">
        <input type="text" className="form-control" id="psForfAmt" />
        <label htmlFor="psForfAmt">P/S Forf Amt</label>
      </div>
      <div className="form-group col-md-2"></div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="employerAllocations"
            />{" "}
            Employer Allocations
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="matchingAllocations"
            />{" "}
            Matching Allocations
          </label>
        </div>
      </div>
      <div className="form-group col-md-2">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="unusedForfeitures"
            />{" "}
            Unused Forfeitures
          </label>
        </div>
      </div>
      <div className="form-group col-md-2"></div>
      <div className="form-group col-md-2"></div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="shMatchCalc"
            />{" "}
            SH Match - Calc
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="shNonElectiveCalc"
            />{" "}
            SH Non Elective - Calc
          </label>
        </div>
      </div>
      <div className="form-group col-md-2"></div>
      <div className="form-group col-md-2"></div>
      <div className="form-group col-md-2"></div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <label>SCRIPTING</label>
      </div>
      <div className="form-group col-md-6">
        <label>PLAN FEATURES</label>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-6">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="mmlContribution"
            />{" "}
            MML Contribution
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="stopAutomation"
            />{" "}
            Stop Automation
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="easyEligibility"
            />{" "}
            EASY Eligibility
          </label>
        </div>
        <input type="text" className="form-control" id="ascNumber" />
        <label htmlFor="ascNumber">ASC Number</label>
      </div>
      <div className="form-group col-md-3">
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="safeHarborPlan"
            />{" "}
            Safe Harbor Plan
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="safeHarborAdpAcp"
            />{" "}
            Safe Harbor ADP/ACP
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="simplePlan"
            />{" "}
            Simple Plan
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="newComp" />{" "}
            New Comp
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="ageWeighted"
            />{" "}
            Age Weighted
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="afterTax" />{" "}
            After Tax
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="nonErisaPlan"
            />{" "}
            Non Erisa Plan
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="matchOnlyPlan"
            />{" "}
            Match Only Plan
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="qaca" />{" "}
            QACA
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="eaca" />{" "}
            EACA (6 month correction)
          </label>
        </div>
      </div>
      <div className="form-group col-md-3">
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="svcMatch" />{" "}
            Svc Match
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="nav" /> NAV
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input type="checkbox" className="form-check-input" id="pdiData" />{" "}
            PDI Data
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="lifeInsurance"
            />{" "}
            Life Insurance
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="churchCertiInsert"
            />{" "}
            Church Certi Insert
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="noCatchup"
            />{" "}
            No Catch-up
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="multipleEr"
            />{" "}
            Multiple ER
          </label>
        </div>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="controlledGroup"
            />{" "}
            Controlled Group
          </label>
        </div>
        <button
          type="button"
          className="btn btn-primary"
          id="controlledGroupButton"
        >
          Controlled Group
        </button>
        <div className="form-check">
          <label className="form-check-label">
            <input
              type="checkbox"
              className="form-check-input"
              id="testByLocation"
            />{" "}
            Test By Location
          </label>
        </div>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-12">
        <input type="text" className="form-control" id="installationNote" />
        <label htmlFor="installationNote">Comments</label>
      </div>
    </div>
    <div className="form-row">
      <div className="form-group col-md-3">
        <button type="button" className="btn btn-primary" id="planSpecs">
          Plan Specs
        </button>
      </div>
      <div className="form-group col-md-3">
        <button type="button" className="btn btn-primary" id="pyeTesting2">
          PYE Testing
        </button>
      </div>
      <div className="form-group col-md-3">
        <button type="button" className="btn btn-primary" id="pyeQa">
          PYE QA
        </button>
      </div>
      <div className="form-group col-md-3">
        <button type="button" className="btn btn-primary" id="teamChecklist">
          Team Checklist
        </button>
      </div>
    </div>
    <button type="submit" className="btn btn-primary">
      Submit
    </button>
  </form>
)

package com.empower.email;

import java.io.IOException;
import java.io.InputStream;

//import java.net.http.HttpHeaders;
import org.springframework.http.HttpHeaders;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.http.MediaType;
import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.UrlResource;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;


@RestController
@CrossOrigin("*")
public class Emailcon {
	@Autowired
	private JavaMailSender mailsend;
	private static final String UPLOAD_DIR = "D:\\python presidency";
	
	@GetMapping("/files")
    public ResponseEntity<List<String>> getFiles() {
        try {
            // List all files in the directory
            List<String> files = Arrays.stream(Paths.get(UPLOAD_DIR).toFile().list())
                    .collect(Collectors.toList());
            return ResponseEntity.ok(files);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(null);
        }
    }
//	@GetMapping("/{filename}")
//	public static void openFile(@PathVariable String filePath) {
//        try {
//            // Convert the file path to a URI
//            URI uri = Paths.get(filePath).toUri();
//
//            // Open the file with the default system application
//            Desktop.getDesktop().browse(uri);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }

//	@GetMapping("/{filename}")
//	public ResponseEntity<UrlResource> downloadFile(@PathVariable String filename) {
//	    try {
//	        // Load file as UrlResource
//	        Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
//	        UrlResource urlResource = new UrlResource(filePath.toUri());
//
//	        // Check if the file exists
//	        if (urlResource.exists()) {
//	            return ResponseEntity.ok()
//	                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + urlResource.getFilename() + "\"")
//	                    .body(urlResource);
//	        } else {
//	            return ResponseEntity.status(404).body(null);
//	        }
//	    } catch (IOException e) {
//	        return ResponseEntity.status(500).body(null);
//	    }
//	}
	
	

	// ... (other imports)

	@GetMapping("/{filename}")
    public ResponseEntity<byte[]> downloadFile(@PathVariable String filename) {
        try {
            // Load file content as bytes
            Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
            byte[] fileContent = Files.readAllBytes(filePath);

            // Determine the media type based on the file extension
            MediaType mediaType = determineMediaType(filename);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(mediaType);

            return ResponseEntity.ok()
                    .headers(headers)
                    .body(fileContent);
        } catch (IOException e) {
            return ResponseEntity.status(500).body(null);
        }
    }

    private MediaType determineMediaType(String filename) {
        String fileExtension = filename.substring(filename.lastIndexOf('.') + 1).toLowerCase();

        switch (fileExtension) {
        	case "xml":
        		return MediaType.APPLICATION_ATOM_XML;
        	case "json":
        		return MediaType.APPLICATION_JSON;
            case "pdf":
                return MediaType.APPLICATION_PDF;
            case "jpg":
            case "jpeg":
            case "png":
            case "gif":
                return MediaType.IMAGE_JPEG; // or MediaType.IMAGE_PNG for PNG files
            // Add more cases for other file types if needed
            default:
                return MediaType.APPLICATION_OCTET_STREAM;
        }
    }
    

	@PostMapping("/balu")
	public void adds()
	{
		System.out.println("hello adds");
	}
	@PostMapping("/gmail")
	public void fun1(@RequestBody Emailentity entity)
	{
		SimpleMailMessage message=new SimpleMailMessage();
		message.setTo(entity.getTo());
		message.setSubject(entity.getSubject());
		message.setText(entity.getBody());
		mailsend.send(message);
		System.out.println("message");
	}
}



import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.http.MediaType;
import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.UrlResource;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
@GetMapping("/files")
    public ResponseEntity<List<String>> getFiles() {
        try {
            // List all files in the directory
            List<String> files = Arrays.stream(Paths.get(UPLOAD_DIR).toFile().list())
                    .collect(Collectors.toList());
            return ResponseEntity.ok(files);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(null);
        }
    }


@GetMapping("/{filename}")
    public ResponseEntity<byte[]> downloadFile(@PathVariable String filename) {
        try {
            // Load file content as bytes
            Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
            byte[] fileContent = Files.readAllBytes(filePath);

            // Determine the media type based on the file extension
            MediaType mediaType = determineMediaType(filename);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(mediaType);

            return ResponseEntity.ok()
                    .headers(headers)
                    .body(fileContent);
        } catch (IOException e) {
            return ResponseEntity.status(500).body(null);
        }
    }

    private MediaType determineMediaType(String filename) {
        String fileExtension = filename.substring(filename.lastIndexOf('.') + 1).toLowerCase();

        switch (fileExtension) {
        	case "xml":
        		return MediaType.APPLICATION_ATOM_XML;
        	case "json":
        		return MediaType.APPLICATION_JSON;
            case "pdf":
                return MediaType.APPLICATION_PDF;
            case "jpg":
            case "jpeg":
            case "png":
            case "gif":
                return MediaType.IMAGE_JPEG; // or MediaType.IMAGE_PNG for PNG files
            // Add more cases for other file types if needed
            default:
                return MediaType.APPLICATION_OCTET_STREAM;
        }
    }
ompx rsvq bfaw zdyv

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

spring.mail.host=smtp.example.com
spring.mail.port=587
spring.mail.username=your-email@example.com
spring.mail.password=your-email-password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class EmailController {

    @Autowired
    private JavaMailSender emailSender;

    @PostMapping("/sendEmail")
    public void sendEmail(@RequestBody EmailRequest emailRequest) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(emailRequest.getTo());
        message.setSubject(emailRequest.getSubject());
        message.setText(emailRequest.getBody());

        emailSender.send(message);
    }
}





const [loading, setLoading] = useState(true); // Added loading state



@RestController
@RequestMapping("/api/files")
public class FileController {

    private static final String D_DRIVE_PATH = "D:/your/folder/path/";

    @GetMapping("/list")
    public ResponseEntity<List<String>> getFileList() {
        File folder = new File(D_DRIVE_PATH);
        String[] fileList = folder.list();
        return ResponseEntity.ok(Arrays.asList(fileList));
    }

    @GetMapping("/download")
    public ResponseEntity<Resource> downloadFile(@RequestParam String fileName) throws IOException {
        File file = new File(D_DRIVE_PATH + fileName);
        InputStreamResource resource = new InputStreamResource(new FileInputStream(file));

        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + fileName);

        return ResponseEntity.ok()
                .headers(headers)
                .contentLength(file.length())
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(resource);
    }
}




react:


import React, { useState, useEffect } from 'react';
import axios from 'axios';

const FileList = () => {
  const [files, setFiles] = useState([]);

  useEffect(() => {
    // Fetch the list of files from the backend
    axios.get('http://your-backend-url/api/files/list')
      .then(response => setFiles(response.data))
      .catch(error => console.error('Error fetching file list:', error));
  }, []);

  const handleFileClick = (fileName) => {
    // Download the selected file from the backend
    window.open(`http://your-backend-url/api/files/download?fileName=${fileName}`);
  };

  return (
    <div>
      <h2>File List:</h2>
      <ul>
        {files.map((file, index) => (
          <li key={index} onClick={() => handleFileClick(file)}>
            {file}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default FileList;






import org.springframework.core.io.InputStreamResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

@RestController
public class FileController {

    private static final String D_DRIVE_PATH = "D:/your/folder/path/";

    @GetMapping("/api/files/download")
    public ResponseEntity<InputStreamResource> downloadFile(@RequestParam String fileName) throws IOException {
        File file = new File(D_DRIVE_PATH + fileName);

        if (file.exists()) {
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + fileName);

            InputStreamResource resource = new InputStreamResource(new FileInputStream(file));

            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(file.length())
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}
